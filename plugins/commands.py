import os
import re, sys
import json
import base64
import logging
import random
import asyncio
import string
import pytz
from .pmfilter import auto_filter 
from Script import script
from datetime import datetime
from database.refer import referdb
from database.config_db import mdb
from pyrogram import Client, filters, enums
from pyrogram.errors import FloodWait, ChatAdminRequired, UserNotParticipant
from pyrogram.types import *
from database.ia_filterdb import Media, Media2, get_file_details, unpack_new_file_id, get_bad_files
from database.users_chats_db import db
from info import *
from utils import get_settings, save_group_settings, is_subscribed, is_req_subscribed, get_size, get_shortlink, is_check_admin, temp, get_readable_time, get_time, generate_settings_text, log_error, clean_filename,save_default_settings
import traceback


logging.basicConfig(level=logging.ERROR)
logger = logging.getLogger(__name__)

TIMEZONE = "Asia/Kolkata"
BATCH_FILES = {}

@Client.on_message(filters.command("start") & filters.incoming)
async def start(client, message):
    if EMOJI_MODE:
        try:
            await message.react(emoji=random.choice(REACTIONS), big=True)
        except Exception:
            await message.react(emoji="‚ö°Ô∏è", big=True)
    m = message
    if len(m.command) == 2 and m.command[1].startswith(('notcopy', 'sendall')):
        _, userid, verify_id, file_id = m.command[1].split("_", 3)
        user_id = int(userid)
        grp_id = temp.VERIFICATIONS.get(user_id, 0)
        settings = await get_settings(grp_id)         
        verify_id_info = await db.get_verify_id_info(user_id, verify_id)
        if not verify_id_info or verify_id_info["verified"]:
            return await message.reply("<b> ü…™…¥·¥ã ·¥áx·¥ò…™ Ä·¥á·¥Ö ·¥õ Ä è ·¥Ä…¢·¥Ä…™…¥...</b>")  
        
        ist_timezone = pytz.timezone('Asia/Kolkata')
        if await db.user_verified(user_id):
            key = "third_time_verified"
        else:
            key = "second_time_verified" if await db.is_user_verified(user_id) else "last_verified"
        current_time = datetime.now(tz=ist_timezone)
        result = await db.update_notcopy_user(user_id, {key:current_time})
        await db.update_verify_id_info(user_id, verify_id, {"verified":True})
        if key == "third_time_verified": 
            num = 3 
        else: 
            num =  2 if key == "second_time_verified" else 1 
        if key == "third_time_verified": 
            msg = script.THIRDT_VERIFY_COMPLETE_TEXT
        else:
            msg = script.SECOND_VERIFY_COMPLETE_TEXT if key == "second_time_verified" else script.VERIFY_COMPLETE_TEXT
        if message.command[1].startswith('sendall'):
            verifiedfiles = f"https://telegram.me/{temp.U_NAME}?start=allfiles_{grp_id}_{file_id}"
        else:
            verifiedfiles = f"https://telegram.me/{temp.U_NAME}?start=file_{grp_id}_{file_id}"
        await client.send_message(settings['log'], script.VERIFIED_LOG_TEXT.format(m.from_user.mention, user_id, datetime.now(pytz.timezone('Asia/Kolkata')).strftime('%d %B %Y'), num))
        btn = [[
            InlineKeyboardButton("‚úÖ ·¥Ñ ü…™·¥Ñ·¥ã  ú·¥á Ä·¥á ·¥õ·¥è …¢·¥á·¥õ Íú∞…™ ü·¥á ‚úÖ", url=verifiedfiles),
        ]]
        reply_markup=InlineKeyboardMarkup(btn)
        dlt=await m.reply_photo(
            photo=(VERIFY_IMG),
            caption=msg.format(message.from_user.mention, get_readable_time(TWO_VERIFY_GAP)),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )
        await asyncio.sleep(300)
        await dlt.delete()
        return         
    if message.chat.type in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        buttons = [[
                    InlineKeyboardButton('‚ù§Ô∏è ·¥Ä·¥Ö·¥Ö ·¥ç·¥á ·¥õ·¥è  è·¥è·¥ú Ä …¢ Ä·¥è·¥ú·¥ò ‚ù§Ô∏è', url=f'http://t.me/{temp.U_NAME}?startgroup=true')
                ],[
                    InlineKeyboardButton('üçÅ Update Channel üçÅ', url=UPDATE_CHNL_LNK)
                  ]]
        reply_markup = InlineKeyboardMarkup(buttons)
        await message.reply(script.GSTART_TXT.format(message.from_user.mention if message.from_user else message.chat.title, temp.U_NAME, temp.B_NAME), reply_markup=reply_markup, disable_web_page_preview=True)
        await asyncio.sleep(2) 
        if not await db.get_chat(message.chat.id):
            total=await client.get_chat_members_count(message.chat.id)
            await client.send_message(LOG_CHANNEL, script.LOG_TEXT_G.format(message.chat.title, message.chat.id, total, "Unknown"))       
            await db.add_chat(message.chat.id, message.chat.title)
        return 
    if not await db.is_user_exist(message.from_user.id):
        await db.add_user(message.from_user.id, message.from_user.first_name)
        await client.send_message(LOG_CHANNEL, script.LOG_TEXT_P.format(message.from_user.id, message.from_user.mention))
    if len(message.command) != 2:
        buttons = [[
                    InlineKeyboardButton('üî∞ ·¥Ä·¥Ö·¥Ö ·¥ç·¥á ·¥õ·¥è  è·¥è·¥ú Ä …¢ Ä·¥è·¥ú·¥ò üî∞', url=f'http://telegram.me/{temp.U_NAME}?startgroup=true')
                ],[
                    InlineKeyboardButton('  ú·¥á ü·¥ò üì¢', callback_data='help'),
                    InlineKeyboardButton(' ·¥Ä ô·¥è·¥ú·¥õ üìñ', callback_data='about')
                ],[
                    InlineKeyboardButton('·¥õ·¥è·¥ò s·¥á·¥Ä Ä·¥Ñ ú…™…¥…¢ ‚≠ê', callback_data="topsearch"),
                    InlineKeyboardButton('·¥ú·¥ò…¢ Ä·¥Ä·¥Ö·¥á üéü', callback_data="premium_info"),
                ]]
        reply_markup = InlineKeyboardMarkup(buttons)
        current_time = datetime.now(pytz.timezone(TIMEZONE))
        curr_time = current_time.hour        
        if curr_time < 12:
            gtxt = "…¢·¥è·¥è·¥Ö ·¥ç·¥è Ä…¥…™…¥…¢ üåû" 
        elif curr_time < 17:
            gtxt = "…¢·¥è·¥è·¥Ö ·¥Ä“ì·¥õ·¥á Ä…¥·¥è·¥è…¥ üåì" 
        elif curr_time < 21:
            gtxt = "…¢·¥è·¥è·¥Ö ·¥á·¥†·¥á…¥…™…¥…¢ üåò"
        else:
            gtxt = "…¢·¥è·¥è·¥Ö …¥…™…¢ ú·¥õ üåë"
        m=await message.reply_text("‚è≥")
        await asyncio.sleep(0.4)
        await m.delete()        
        await message.reply_photo(
            photo=random.choice(PICS),
            caption=script.START_TXT.format(message.from_user.mention, gtxt, temp.U_NAME, temp.B_NAME),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )
        return

    if len(message.command) == 2 and message.command[1] in ["subscribe", "error", "okay", "help"]:
        buttons = [[
                    InlineKeyboardButton('üî∞ ·¥Ä·¥Ö·¥Ö ·¥ç·¥á ·¥õ·¥è  è·¥è·¥ú Ä …¢ Ä·¥è·¥ú·¥ò üî∞', url=f'http://telegram.me/{temp.U_NAME}?startgroup=true')
                ],[
                    InlineKeyboardButton('  ú·¥á ü·¥ò üì¢', callback_data='help'),
                    InlineKeyboardButton(' ·¥Ä ô·¥è·¥ú·¥õ üìñ', callback_data='about')
                ],[
                    InlineKeyboardButton('·¥õ·¥è·¥ò s·¥á·¥Ä Ä·¥Ñ ú…™…¥…¢ ‚≠ê', callback_data="topsearch"),
                    InlineKeyboardButton('·¥ú·¥ò…¢ Ä·¥Ä·¥Ö·¥á üéü', callback_data="premium_info"),
                ]]
        reply_markup = InlineKeyboardMarkup(buttons)
        current_time = datetime.now(pytz.timezone(TIMEZONE))
        curr_time = current_time.hour        
        if curr_time < 12:
            gtxt = "…¢·¥è·¥è·¥Ö ·¥ç·¥è Ä…¥…™…¥…¢ üåû" 
        elif curr_time < 17:
            gtxt = "…¢·¥è·¥è·¥Ö ·¥Ä“ì·¥õ·¥á Ä…¥·¥è·¥è…¥ üåì" 
        elif curr_time < 21:
            gtxt = "…¢·¥è·¥è·¥Ö ·¥á·¥†·¥á…¥…™…¥…¢ üåò"
        else:
            gtxt = "…¢·¥è·¥è·¥Ö …¥…™…¢ ú·¥õ üåë"
        m=await message.reply_text("‚è≥")
        await asyncio.sleep(0.4)
        await m.delete()        
        await message.reply_photo(
            photo=random.choice(PICS),
            caption=script.START_TXT.format(message.from_user.mention, gtxt, temp.U_NAME, temp.B_NAME),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )
        return
    if message.command[1].startswith("reff_"):
        try:
            user_id = int(message.command[1].split("_")[1])
        except ValueError:
            await message.reply_text("Invalid refer!")
            return
        if user_id == message.from_user.id:
            await message.reply_text("H·¥á è D·¥ú·¥Ö·¥á, Y·¥è·¥ú C·¥Ä…¥'·¥õ R·¥á“ì·¥á Ä Y·¥è·¥ú Äs·¥á ü“ì ü§£!\n\ns ú·¥Ä Ä·¥á  ü…™…¥·¥ã  è·¥è·¥ú Ä “ì Ä…™·¥á…¥·¥Ö ·¥Ä…¥·¥Ö …¢·¥á·¥õ 10  Ä·¥á“ì·¥á Ä Ä·¥Ä ü ·¥ò·¥è…™…¥·¥õ …™“ì  è·¥è·¥ú ·¥Ä Ä·¥á ·¥Ñ·¥è ü ü·¥á·¥Ñ·¥õ…™…¥…¢ 100  Ä·¥á“ì·¥á Ä Ä·¥Ä ü ·¥ò·¥è…™…¥·¥õs ·¥õ ú·¥á…¥  è·¥è·¥ú ·¥Ñ·¥Ä…¥ …¢·¥á·¥õ 1 ·¥ç·¥è…¥·¥õ ú “ì Ä·¥á·¥á ·¥ò Ä·¥á·¥ç…™·¥ú·¥ç ·¥ç·¥á·¥ç ô·¥á Äs ú…™·¥ò.")
            return
        if referdb.is_user_in_list(message.from_user.id):
            await message.reply_text("Y·¥è·¥ú  ú·¥Ä·¥†·¥á  ô·¥á·¥á…¥ ·¥Ä ü Ä·¥á·¥Ä·¥Ö è …™…¥·¥†…™·¥õ·¥á·¥Ö ‚ùó")
            return
        try:
            uss = await client.get_users(user_id)
        except Exception:
            return 	    
        referdb.add_user(message.from_user.id)
        fromuse = referdb.get_refer_points(user_id) + 10
        if fromuse == 100:
            referdb.add_refer_points(user_id, 0) 
            await message.reply_text(f"üéâ ùóñùóºùóªùó¥ùóøùóÆùòÅùòÇùóπùóÆùòÅùó∂ùóºùóªùòÄ! ùó¨ùóºùòÇ ùòÑùóºùóª ùü≠ùü¨ ùó•ùó≤ùó≥ùó≤ùóøùóøùóÆùóπ ùóΩùóºùó∂ùóªùòÅ ùóØùó≤ùó∞ùóÆùòÇùòÄùó≤ ùó¨ùóºùòÇ ùóµùóÆùòÉùó≤ ùóØùó≤ùó≤ùóª ùó¶ùòÇùó∞ùó∞ùó≤ùòÄùòÄùó≥ùòÇùóπùóπùòÜ ùóúùóªùòÉùó∂ùòÅùó≤ùó± ‚òû {uss.mention}!")		    
            await message.reply_text(user_id, f"You have been successfully invited by {message.from_user.mention}!") 	
            seconds = 2592000
            if seconds > 0:
                expiry_time = datetime.datetime.now() + datetime.timedelta(seconds=seconds)
                user_data = {"id": user_id, "expiry_time": expiry_time}  # Using "id" instead of "user_id"  
                await db.update_user(user_data)  # Use the update_user method to update or insert user data		    
                await client.send_message(
                chat_id=user_id,
                text=f"<b>H·¥á è {uss.mention}\n\nY·¥è·¥ú …¢·¥è·¥õ 1 ·¥ç·¥è…¥·¥õ ú ·¥ò Ä·¥á·¥ç…™·¥ú·¥ç s·¥ú ôs·¥Ñ Ä…™·¥ò·¥õ…™·¥è…¥  ô è …™…¥·¥†…™·¥õ…™…¥…¢ 10 ·¥ús·¥á Äs ‚ùó", disable_web_page_preview=True              
                )
            for admin in ADMINS:
                await client.send_message(chat_id=admin, text=f"S·¥ú·¥Ñ·¥Ñ·¥áss “ì·¥ú ü ü è ·¥õ·¥Äs·¥ã ·¥Ñ·¥è·¥ç·¥ò ü·¥á·¥õ·¥á·¥Ö  ô è ·¥õ ú…™s ·¥ús·¥á Ä:\n\nuser N·¥Ä·¥ç·¥á: {uss.mention}\n\nUs·¥á Ä …™·¥Ö: {uss.id}!")	
        else:
            referdb.add_refer_points(user_id, fromuse)
            await message.reply_text(f"You have been successfully invited by {uss.mention}!")
            await client.send_message(user_id, f"ùóñùóºùóªùó¥ùóøùóÆùòÅùòÇùóπùóÆùòÅùó∂ùóºùóªùòÄ! ùó¨ùóºùòÇ ùòÑùóºùóª ùü≠ùü¨ ùó•ùó≤ùó≥ùó≤ùóøùóøùóÆùóπ ùóΩùóºùó∂ùóªùòÅ ùóØùó≤ùó∞ùóÆùòÇùòÄùó≤ ùó¨ùóºùòÇ ùóµùóÆùòÉùó≤ ùóØùó≤ùó≤ùóª ùó¶ùòÇùó∞ùó∞ùó≤ùòÄùòÄùó≥ùòÇùóπùóπùòÜ ùóúùóªùòÉùó∂ùòÅùó≤ùó± ‚òû{message.from_user.mention}!")
        return
        
    if len(message.command) == 2 and message.command[1] in ["premium"]:
        buttons = [[
                    InlineKeyboardButton('üì≤ Íú±·¥á…¥·¥Ö ·¥ò·¥Ä è·¥ç·¥á…¥·¥õ Íú±·¥Ñ Ä·¥á·¥á…¥Íú± ú·¥è·¥õ', url=OWNER_LNK)
                  ],[
                    InlineKeyboardButton('‚ùå ·¥Ñ ü·¥èÍú±·¥á ‚ùå', callback_data='close_data')
                  ]]
        reply_markup = InlineKeyboardMarkup(buttons)
        await message.reply_photo(
            photo=(SUBSCRIPTION),
            caption=script.PREPLANS_TXT.format(message.from_user.mention, OWNER_UPI_ID, QR_CODE),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )
        return  
    
    if len(message.command) == 2 and message.command[1].startswith('getfile'):
        movies = message.command[1].split("-", 1)[1] 
        movie = movies.replace('-',' ')
        message.text = movie 
        await auto_filter(client, message) 
        return
    
    data = message.command[1]
    try:
        pre, grp_id, file_id = data.split('_', 2)
    except Exception:
        pre, grp_id, file_id = "", 0, data

   
    if not await db.has_premium_access(message.from_user.id):
        btn = []
        try:
            chat = int(data.split("_", 2)[1])
            if AUTH_CHANNELS:
                settings      = await get_settings(chat)
                fsub_channels = settings.get("fsub", AUTH_CHANNELS) if settings else AUTH_CHANNELS
                btn += await is_subscribed(client, message.from_user.id, fsub_channels)
            if AUTH_REQ_CHANNELS:
                settings        = await get_settings(chat)
                rqfsub_channels = settings.get("reqfsub", AUTH_REQ_CHANNELS) if settings else AUTH_REQ_CHANNELS
                btn += await is_req_subscribed(client, message.from_user.id, rqfsub_channels)
            if btn:
                if len(message.command) > 1 and "_" in message.command[1]:
                    kk, file_id = message.command[1].split("_", 1)
                    btn.append([
                        InlineKeyboardButton("‚ôªÔ∏è ·¥õ Ä è ·¥Ä…¢·¥Ä…™…¥ ‚ôªÔ∏è", callback_data=f"checksub#{kk}#{file_id}")
                    ])
                    reply_markup = InlineKeyboardMarkup(btn)
                caption = (
                    f"üëã  ú·¥á ü ü·¥è {message.from_user.mention}\n\n"
                    "üõë  è·¥è·¥ú ·¥ç·¥ús·¥õ ·¥ä·¥è…™…¥ ·¥õ ú·¥á  Ä·¥á«´·¥ú…™ Ä·¥á·¥Ö ·¥Ñ ú·¥Ä…¥…¥·¥á üs ·¥õ·¥è ·¥Ñ·¥è…¥·¥õ…™…¥·¥ú·¥á.\n"
                    "üëâ ·¥ä·¥è…™…¥ ·¥Ä ü ü ·¥õ ú·¥á  ô·¥á ü·¥è·¥° ·¥Ñ ú·¥Ä…¥…¥·¥á üs ·¥Ä…¥·¥Ö ·¥õ Ä è ·¥Ä…¢·¥Ä…™…¥."
                )
                photo = random.choice(FSUB_PICS) if FSUB_PICS else "https://graph.org/file/7478ff3eac37f4329c3d8.jpg"
                await message.reply_photo(
                    photo=photo,
                    caption=caption,
                    reply_markup=reply_markup,
                    parse_mode=enums.ParseMode.HTML
                )
                return

        except Exception as e:
            await log_error(client, f"‚ùóÔ∏è Force Sub Error:\n\n{repr(e)}")
            logger.error(f"‚ùóÔ∏è Force Sub Error:\n\n{repr(e)}")


    
    user_id = m.from_user.id
    if not await db.has_premium_access(user_id):
        try:
            grp_id = int(grp_id)
            user_verified = await db.is_user_verified(user_id)
            settings = await get_settings(grp_id)
            is_second_shortener = await db.use_second_shortener(user_id, settings.get('verify_time', TWO_VERIFY_GAP)) 
            is_third_shortener = await db.use_third_shortener(user_id, settings.get('third_verify_time', THREE_VERIFY_GAP))
            if settings.get("is_verify", IS_VERIFY) and (not user_verified or is_second_shortener or is_third_shortener):
                verify_id = ''.join(random.choices(string.ascii_uppercase + string.digits, k=7))
                await db.create_verify_id(user_id, verify_id)
                temp.VERIFICATIONS[user_id] = grp_id
                if message.command[1].startswith('allfiles'):
                    verify = await get_shortlink(f"https://telegram.me/{temp.U_NAME}?start=sendall_{user_id}_{verify_id}_{file_id}", grp_id, is_second_shortener, is_third_shortener)
                else:
                    verify = await get_shortlink(f"https://telegram.me/{temp.U_NAME}?start=notcopy_{user_id}_{verify_id}_{file_id}", grp_id, is_second_shortener, is_third_shortener)
                if is_third_shortener:
                    howtodownload = settings.get('tutorial_3', TUTORIAL_3)
                else:
                    howtodownload = settings.get('tutorial_2', TUTORIAL_2) if is_second_shortener else settings.get('tutorial', TUTORIAL)
                buttons = [[
                    InlineKeyboardButton(text="‚ôªÔ∏è ·¥Ñ ü…™·¥Ñ·¥ã  ú·¥á Ä·¥á ·¥õ·¥è ·¥†·¥á Ä…™Íú∞ è ‚ôªÔ∏è", url=verify)
                ],[
                    InlineKeyboardButton(text="‚ÅâÔ∏è  ú·¥è·¥° ·¥õ·¥è ·¥†·¥á Ä…™Íú∞ è ‚ÅâÔ∏è", url=howtodownload)
                ]]
                reply_markup=InlineKeyboardMarkup(buttons)
                if await db.user_verified(user_id): 
                    msg = script.THIRDT_VERIFICATION_TEXT
                else:            
                    msg = script.SECOND_VERIFICATION_TEXT if is_second_shortener else script.VERIFICATION_TEXT
                n=await m.reply_text(
                    text=msg.format(message.from_user.mention),
                    protect_content = True,
                    reply_markup=reply_markup,
                    parse_mode=enums.ParseMode.HTML
                )
                await asyncio.sleep(300) 
                await n.delete()
                await m.delete()
                return
        except Exception as e:
            print(f"Error In Verification - {e}")
            pass

    if data.startswith("allfiles"):
        try:
            files = temp.GETALL.get(file_id)
            if not files:
                return await message.reply('<b><i>…¥·¥è Íú±·¥ú·¥Ñ ú Íú∞…™ ü·¥á ·¥áx…™Íú±·¥õÍú± !</b></i>')
            filesarr = []
            for file in files:
                file_id = file.file_id
                files_ = await get_file_details(file_id)
                files1 = files_[0]
                title = clean_filename(files1.file_name)
                size = get_size(files1.file_size)
                f_caption = files1.caption
                settings = await get_settings(int(grp_id))
                DREAMX_CAPTION = settings.get('caption', CUSTOM_FILE_CAPTION)
                if DREAMX_CAPTION:
                    try:
                        f_caption=DREAMX_CAPTION.format(file_name= '' if title is None else title, file_size='' if size is None else size, file_caption='' if f_caption is None else f_caption)
                    except Exception as e:
                        logger.exception(e)
                        f_caption = f_caption
                if f_caption is None:
                    f_caption = f"{clean_filename(files1.file_name)}"
                
                if STREAM_MODE and not PREMIUM_STREAM_MODE:
                    
                    btn = [
                        [InlineKeyboardButton('üöÄ Íú∞·¥ÄÍú±·¥õ ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö / ·¥°·¥Ä·¥õ·¥Ñ ú ·¥è…¥ ü…™…¥·¥á üñ•Ô∏è', callback_data=f'generate_stream_link:{file_id}')],
                        [InlineKeyboardButton('üìå ·¥ä·¥è…™…¥ ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥áÍú± ·¥Ñ ú·¥Ä…¥…¥·¥á ü üìå', url=UPDATE_CHNL_LNK)]  # Keep this line unchanged  
                    ]
                elif STREAM_MODE and PREMIUM_STREAM_MODE:
                    
                    if not await db.has_premium_access(message.from_user.id):
                        
                        btn = [
                            [InlineKeyboardButton('üöÄ Íú∞·¥ÄÍú±·¥õ ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö / ·¥°·¥Ä·¥õ·¥Ñ ú ·¥è…¥ ü…™…¥·¥á üñ•Ô∏è', callback_data=f'prestream')],
                            [InlineKeyboardButton('üìå ·¥ä·¥è…™…¥ ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥áÍú± ·¥Ñ ú·¥Ä…¥…¥·¥á ü üìå', url=UPDATE_CHNL_LNK)]  # Keep this line unchanged  
                        ]
                    else:
                        
                        btn = [
                            [InlineKeyboardButton('üöÄ Íú∞·¥ÄÍú±·¥õ ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö / ·¥°·¥Ä·¥õ·¥Ñ ú ·¥è…¥ ü…™…¥·¥á üñ•Ô∏è', callback_data=f'generate_stream_link:{file_id}')],
                            [InlineKeyboardButton('üìå ·¥ä·¥è…™…¥ ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥áÍú± ·¥Ñ ú·¥Ä…¥…¥·¥á ü üìå', url=UPDATE_CHNL_LNK)]  # Keep this line unchanged  
                        ]
                else:
                    btn = [[InlineKeyboardButton('üìå ·¥ä·¥è…™…¥ ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥áÍú± ·¥Ñ ú·¥Ä…¥…¥·¥á ü üìå', url=UPDATE_CHNL_LNK)]]
                msg = await client.send_cached_media(
                    chat_id=message.from_user.id,
                    file_id=file_id,
                    caption=f_caption,
                    protect_content=settings.get('file_secure', PROTECT_CONTENT),
                    reply_markup=InlineKeyboardMarkup(btn)
                )
                filesarr.append(msg)
            k = await client.send_message(chat_id=message.from_user.id, text=f"<b><u>‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏èIMPORTANT‚ùóÔ∏èÔ∏è‚ùóÔ∏è‚ùóÔ∏è</u></b>\n\n·¥õ ú…™Íú± ·¥ç·¥è·¥†…™·¥á Íú∞…™ ü·¥á/·¥†…™·¥Ö·¥á·¥è ·¥°…™ ü ü  ô·¥á ·¥Ö·¥á ü·¥á·¥õ·¥á·¥Ö …™…¥ <b><u><code>{get_time(DELETE_TIME)}</code></u> ü´• <i></b>(·¥Ö·¥ú·¥á ·¥õ·¥è ·¥Ñ·¥è·¥ò è Ä…™…¢ ú·¥õ …™Íú±Íú±·¥ú·¥áÍú±)</i>.\n\n<b><i>·¥ò ü·¥á·¥ÄÍú±·¥á Íú∞·¥è Ä·¥°·¥Ä Ä·¥Ö ·¥õ ú…™Íú± Íú∞…™ ü·¥á ·¥õ·¥è Íú±·¥è·¥ç·¥á·¥° ú·¥á Ä·¥á ·¥á üÍú±·¥á ·¥Ä…¥·¥Ö Íú±·¥õ·¥Ä Ä·¥õ ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö…™…¥…¢ ·¥õ ú·¥á Ä·¥á</i></b>")
            await asyncio.sleep(DELETE_TIME)
            for x in filesarr:
                await x.delete()
            await k.edit_text("<b> è·¥è·¥ú Ä ·¥Ä ü ü ·¥†…™·¥Ö·¥á·¥èÍú±/Íú∞…™ ü·¥áÍú± ·¥Ä Ä·¥á ·¥Ö·¥á ü·¥á·¥õ·¥á·¥Ö Íú±·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü ü è !\n·¥ã…™…¥·¥Ö ü è Íú±·¥á·¥Ä Ä·¥Ñ ú ·¥Ä…¢·¥Ä…™…¥</b>")
            return
        except Exception as e:
            logger.exception(e)
            return

    user = message.from_user.id
    files_ = await get_file_details(file_id)
    settings = await get_settings(int(grp_id))
    if not files_:
        pre, file_id = ((base64.urlsafe_b64decode(data + "=" * (-len(data) % 4))).decode("ascii")).split("_", 1)
        try:
            if STREAM_MODE and not PREMIUM_STREAM_MODE:
                btn = [
                    [InlineKeyboardButton('üöÄ Íú∞·¥ÄÍú±·¥õ ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö / ·¥°·¥Ä·¥õ·¥Ñ ú ·¥è…¥ ü…™…¥·¥á üñ•Ô∏è', callback_data=f'generate_stream_link:{file_id}')],
                    [InlineKeyboardButton('üìå ·¥ä·¥è…™…¥ ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥áÍú± ·¥Ñ ú·¥Ä…¥…¥·¥á ü üìå', url=UPDATE_CHNL_LNK)]  # Keep this line unchanged  
                ]
            elif STREAM_MODE and PREMIUM_STREAM_MODE:
                if not await db.has_premium_access(message.from_user.id):
                   btn = [
                        [InlineKeyboardButton('üöÄ Íú∞·¥ÄÍú±·¥õ ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö / ·¥°·¥Ä·¥õ·¥Ñ ú ·¥è…¥ ü…™…¥·¥á üñ•Ô∏è', callback_data=f'prestream')],
                        [InlineKeyboardButton('üìå ·¥ä·¥è…™…¥ ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥áÍú± ·¥Ñ ú·¥Ä…¥…¥·¥á ü üìå', url=UPDATE_CHNL_LNK)]  # Keep this line unchanged  
                    ]
                else:
                    btn = [
                        [InlineKeyboardButton('üöÄ Íú∞·¥ÄÍú±·¥õ ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö / ·¥°·¥Ä·¥õ·¥Ñ ú ·¥è…¥ ü…™…¥·¥á üñ•Ô∏è', callback_data=f'generate_stream_link:{file_id}')],
                        [InlineKeyboardButton('üìå ·¥ä·¥è…™…¥ ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥áÍú± ·¥Ñ ú·¥Ä…¥…¥·¥á ü üìå', url=UPDATE_CHNL_LNK)]  # Keep this line unchanged  
                    ]
            else:
            
                btn = [[InlineKeyboardButton('üìå ·¥ä·¥è…™…¥ ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥áÍú± ·¥Ñ ú·¥Ä…¥…¥·¥á ü üìå', url=UPDATE_CHNL_LNK)]] 
            msg = await client.send_cached_media(
                chat_id=message.from_user.id,
                file_id=file_id,
                protect_content=settings.get('file_secure', PROTECT_CONTENT),
                reply_markup=InlineKeyboardMarkup(btn))

            filetype = msg.media
            file = getattr(msg, filetype.value)
            title = clean_filename(file.file_name)
            size=get_size(file.file_size)
            f_caption = f"<code>{title}</code>"
            settings = await get_settings(int(grp_id))
            DREAMX_CAPTION = settings.get('caption', CUSTOM_FILE_CAPTION)
            if DREAMX_CAPTION:
                try:
                    f_caption=DREAMX_CAPTION.format(file_name= '' if title is None else title, file_size='' if size is None else size, file_caption='')
                except:
                    return
            await msg.edit_caption(
                f_caption,
                reply_markup=InlineKeyboardMarkup(btn)
            )
            k = await msg.reply(
                f"<b><u>‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏èIMPORTANT‚ùóÔ∏èÔ∏è‚ùóÔ∏è‚ùóÔ∏è</u></b>\n\n"
                f"·¥õ ú…™Íú± ·¥ç·¥è·¥†…™·¥á Íú∞…™ ü·¥á/·¥†…™·¥Ö·¥á·¥è ·¥°…™ ü ü  ô·¥á ·¥Ö·¥á ü·¥á·¥õ·¥á·¥Ö …™…¥ <b><u><code>{get_time(DELETE_TIME)}</code></u> ü´• <i></b>"
                "(·¥Ö·¥ú·¥á ·¥õ·¥è ·¥Ñ·¥è·¥ò è Ä…™…¢ ú·¥õ …™Íú±Íú±·¥ú·¥áÍú±)</i>.\n\n"
                "<b><i>·¥ò ü·¥á·¥ÄÍú±·¥á Íú∞·¥è Ä·¥°·¥Ä Ä·¥Ö ·¥õ ú…™Íú± Íú∞…™ ü·¥á ·¥õ·¥è Íú±·¥è·¥ç·¥á·¥° ú·¥á Ä·¥á ·¥á üÍú±·¥á ·¥Ä…¥·¥Ö Íú±·¥õ·¥Ä Ä·¥õ ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö…™…¥…¢ ·¥õ ú·¥á Ä·¥á</i></b>",
                quote=True
            )
            await asyncio.sleep(DELETE_TIME)
            await msg.delete()
            await k.edit_text("<b> è·¥è·¥ú Ä ·¥†…™·¥Ö·¥á·¥è / Íú∞…™ ü·¥á …™Íú± Íú±·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü ü è ·¥Ö·¥á ü·¥á·¥õ·¥á·¥Ö !!</b>")
            return
        except Exception as e:
            logger.exception(e)
            pass
        return await message.reply('…¥·¥è Íú±·¥ú·¥Ñ ú Íú∞…™ ü·¥á ·¥áx…™Íú±·¥õÍú± !')
    
    files = files_[0]
    title = clean_filename(files.file_name)
    size = get_size(files.file_size)
    f_caption = files.caption
    settings = await get_settings(int(grp_id))            
    DREAMX_CAPTION = settings.get('caption', CUSTOM_FILE_CAPTION)
    if DREAMX_CAPTION:
        try:
            f_caption=DREAMX_CAPTION.format(file_name= '' if title is None else title, file_size='' if size is None else size, file_caption='' if f_caption is None else f_caption)
        except Exception as e:
            logger.exception(e)
            f_caption = f_caption

    if f_caption is None:
        f_caption = clean_filename(files.file_name)
    
    if STREAM_MODE and not PREMIUM_STREAM_MODE:
        btn = [
            [InlineKeyboardButton('üöÄ Íú∞·¥ÄÍú±·¥õ ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö / ·¥°·¥Ä·¥õ·¥Ñ ú ·¥è…¥ ü…™…¥·¥á üñ•Ô∏è', callback_data=f'generate_stream_link:{file_id}')],
            [InlineKeyboardButton('üìå ·¥ä·¥è…™…¥ ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥áÍú± ·¥Ñ ú·¥Ä…¥…¥·¥á ü üìå', url=UPDATE_CHNL_LNK)]  # Keep this line unchanged  
        ]
    elif STREAM_MODE and PREMIUM_STREAM_MODE:
        if not await db.has_premium_access(message.from_user.id):
            btn = [
                [InlineKeyboardButton('üöÄ Íú∞·¥ÄÍú±·¥õ ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö / ·¥°·¥Ä·¥õ·¥Ñ ú ·¥è…¥ ü…™…¥·¥á üñ•Ô∏è', callback_data=f'prestream')],
                [InlineKeyboardButton('üìå ·¥ä·¥è…™…¥ ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥áÍú± ·¥Ñ ú·¥Ä…¥…¥·¥á ü üìå', url=UPDATE_CHNL_LNK)]  # Keep this line unchanged  
            ]
        else:
            btn = [
                [InlineKeyboardButton('üöÄ Íú∞·¥ÄÍú±·¥õ ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö / ·¥°·¥Ä·¥õ·¥Ñ ú ·¥è…¥ ü…™…¥·¥á üñ•Ô∏è', callback_data=f'generate_stream_link:{file_id}')],
                [InlineKeyboardButton('üìå ·¥ä·¥è…™…¥ ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥áÍú± ·¥Ñ ú·¥Ä…¥…¥·¥á ü üìå', url=UPDATE_CHNL_LNK)]  # Keep this line unchanged  
            ]
    else:
        btn = [[InlineKeyboardButton('üìå ·¥ä·¥è…™…¥ ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥áÍú± ·¥Ñ ú·¥Ä…¥…¥·¥á ü üìå', url=UPDATE_CHNL_LNK)]]
    msg = await client.send_cached_media(
        chat_id=message.from_user.id,
        file_id=file_id,
        caption=f_caption,
        protect_content=settings.get('file_secure', PROTECT_CONTENT),
        reply_markup=InlineKeyboardMarkup(btn)
    )
    k = await msg.reply(
        f"<b><u>‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏èIMPORTANT‚ùóÔ∏èÔ∏è‚ùóÔ∏è‚ùóÔ∏è</u></b>\n\n"
        f"·¥õ ú…™Íú± ·¥ç·¥è·¥†…™·¥á Íú∞…™ ü·¥á/·¥†…™·¥Ö·¥á·¥è ·¥°…™ ü ü  ô·¥á ·¥Ö·¥á ü·¥á·¥õ·¥á·¥Ö …™…¥ <b><u><code>{get_time(DELETE_TIME)}</code></u> ü´• <i></b>"
        "(·¥Ö·¥ú·¥á ·¥õ·¥è ·¥Ñ·¥è·¥ò è Ä…™…¢ ú·¥õ …™Íú±Íú±·¥ú·¥áÍú±)</i>.\n\n"
        "<b><i>·¥ò ü·¥á·¥ÄÍú±·¥á Íú∞·¥è Ä·¥°·¥Ä Ä·¥Ö ·¥õ ú…™Íú± Íú∞…™ ü·¥á ·¥õ·¥è Íú±·¥è·¥ç·¥á·¥° ú·¥á Ä·¥á ·¥á üÍú±·¥á ·¥Ä…¥·¥Ö Íú±·¥õ·¥Ä Ä·¥õ ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö…™…¥…¢ ·¥õ ú·¥á Ä·¥á</i></b>",
        quote=True
    )     
    await asyncio.sleep(DELETE_TIME)
    await msg.delete()
    await k.edit_text("<b> è·¥è·¥ú Ä ·¥†…™·¥Ö·¥á·¥è / Íú∞…™ ü·¥á …™Íú± Íú±·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü ü è ·¥Ö·¥á ü·¥á·¥õ·¥á·¥Ö !!</b>")
    return

@Client.on_message(filters.command('channel') & filters.user(ADMINS))
async def channel_info(bot, message):
           
    """Send basic information of channel"""
    if isinstance(CHANNELS, (int, str)):
        channels = [CHANNELS]
    elif isinstance(CHANNELS, list):
        channels = CHANNELS
    else:
        raise ValueError("·¥ú…¥·¥áx·¥ò·¥á·¥Ñ·¥õ·¥á·¥Ö ·¥õ è·¥ò·¥á ·¥èÍú∞ ·¥Ñ ú·¥Ä…¥…¥·¥á üÍú±.")

    text = 'üìë **…™…¥·¥Ö·¥áx·¥á·¥Ö ·¥Ñ ú·¥Ä…¥…¥·¥á üÍú± / …¢ Ä·¥è·¥ú·¥òÍú±  ü…™Íú±·¥õ :**\n'
    for channel in channels:
        chat = await bot.get_chat(channel)
        if chat.username:
            text += '\n@' + chat.username
        else:
            text += '\n' + chat.title or chat.first_name

    text += f'\n\n**·¥õ·¥è·¥õ·¥Ä ü :** {len(CHANNELS)}'

    if len(text) < 4096:
        await message.reply(text)
    else:
        file = 'Indexed channels.txt'
        with open(file, 'w') as f:
            f.write(text)
        await message.reply_document(file)
        os.remove(file)


@Client.on_message(filters.command('logs') & filters.user(ADMINS))
async def log_file(bot, message):
    """Send log file"""
    try:
        await message.reply_document('DreamXlogs.txt', caption="üìë ** ü·¥è…¢Íú±**")
    except Exception as e:
        await message.reply(str(e))

@Client.on_message(filters.command('delete') & filters.user(ADMINS))
async def delete(bot, message):
    """Delete file from database"""
    reply = message.reply_to_message
    if reply and reply.media:
        msg = await message.reply("P Ä·¥è·¥Ñ·¥áss…™…¥…¢...‚è≥", quote=True)
    else:
        await message.reply('R·¥á·¥ò ü è ·¥õ·¥è “ì…™ ü·¥á ·¥°…™·¥õ ú /delete ·¥° ú…™·¥Ñ ú  è·¥è·¥ú ·¥°·¥Ä…¥·¥õ ·¥õ·¥è ·¥Ö·¥á ü·¥á·¥õ·¥á', quote=True)
        return

    for file_type in ("document", "video", "audio"):
        media = getattr(reply, file_type, None)
        if media is not None:
            break
    else:
        await msg.edit('T ú…™s …™s …¥·¥è·¥õ s·¥ú·¥ò·¥ò·¥è Ä·¥õ·¥á·¥Ö “ì…™ ü·¥á “ì·¥è Ä·¥ç·¥Ä·¥õ')
        return
    
    file_id, file_ref = unpack_new_file_id(media.file_id)
    if await Media.count_documents({'file_id': file_id}):
        result = await Media.collection.delete_one({
            '_id': file_id,
        })
    else:
        result = await Media2.collection.delete_one({
            '_id': file_id,
        })
    if result.deleted_count:
        await msg.edit('F…™ ü·¥á …™s s·¥ú·¥Ñ·¥Ñ·¥áss“ì·¥ú ü ü è ·¥Ö·¥á ü·¥á·¥õ·¥á·¥Ö “ì Ä·¥è·¥ç ·¥Ö·¥Ä·¥õ·¥Ä ô·¥Äs·¥á ‚úÖ')
    else:
        file_name = re.sub(r"(_|\-|\.|\+)", " ", str(media.file_name))
        result = await Media.collection.delete_many({
            'file_name': file_name,
            'file_size': media.file_size,
            'mime_type': media.mime_type
            })
        if result.deleted_count:
            await msg.edit('F…™ ü·¥á …™s s·¥ú·¥Ñ·¥Ñ·¥áss“ì·¥ú ü ü è ·¥Ö·¥á ü·¥á·¥õ·¥á·¥Ö “ì Ä·¥è·¥ç ·¥Ö·¥Ä·¥õ·¥Ä ô·¥Äs·¥á ‚úÖ')
        else:
            result = await Media2.collection.delete_many({
                'file_name': file_name,
                'file_size': media.file_size,
                'mime_type': media.mime_type
            })
            if result.deleted_count:
                await msg.edit('F…™ ü·¥á …™s s·¥ú·¥Ñ·¥Ñ·¥áss“ì·¥ú ü ü è ·¥Ö·¥á ü·¥á·¥õ·¥á·¥Ö “ì Ä·¥è·¥ç ·¥Ö·¥Ä·¥õ·¥Ä ô·¥Äs·¥á')
            else:
                result = await Media.collection.delete_many({
                    'file_name': media.file_name,
                    'file_size': media.file_size,
                    'mime_type': media.mime_type
                })
                if result.deleted_count:
                    await msg.edit('F…™ ü·¥á …™s s·¥ú·¥Ñ·¥Ñ·¥áss“ì·¥ú ü ü è ·¥Ö·¥á ü·¥á·¥õ·¥á·¥Ö “ì Ä·¥è·¥ç ·¥Ö·¥Ä·¥õ·¥Ä ô·¥Äs·¥á ‚úÖ')
                else:
                    result = await Media2.collection.delete_many({
                        'file_name': media.file_name,
                        'file_size': media.file_size,
                        'mime_type': media.mime_type
                    })
                    if result.deleted_count:
                        await msg.edit('F…™ ü·¥á …™s s·¥ú·¥Ñ·¥Ñ·¥áss“ì·¥ú ü ü è ·¥Ö·¥á ü·¥á·¥õ·¥á·¥Ö “ì Ä·¥è·¥ç ·¥Ö·¥Ä·¥õ·¥Ä ô·¥Äs·¥á ‚úÖ')
                    else:
                        await msg.edit('F…™ ü·¥á …¥·¥è·¥õ “ì·¥è·¥ú…¥·¥Ö …™…¥ ·¥Ö·¥Ä·¥õ·¥Ä ô·¥Äs·¥á ‚ùå')


@Client.on_message(filters.command('deleteall') & filters.user(ADMINS))
async def delete_all_index(bot, message):
    await message.reply_text(
        '·¥õ ú…™Íú± ·¥°…™ ü ü ·¥Ö·¥á ü·¥á·¥õ·¥á ·¥Ä ü ü  è·¥è·¥ú Ä …™…¥·¥Ö·¥áx·¥á·¥Ö Íú∞…™ ü·¥áÍú± !\n·¥Ö·¥è  è·¥è·¥ú Íú±·¥õ…™ ü ü ·¥°·¥Ä…¥·¥õ ·¥õ·¥è ·¥Ñ·¥è…¥·¥õ…™…¥·¥ú·¥á ?',
        reply_markup=InlineKeyboardMarkup(
            [
                [
                    InlineKeyboardButton(
                        text="‚ö†Ô∏è  è·¥áÍú± ‚ö†Ô∏è", callback_data="autofilter_delete"
                    )
                ],
                [
                    InlineKeyboardButton(
                        text="‚ùå …¥·¥è ‚ùå", callback_data="close_data"
                    )
                ],
            ]
        ),
        quote=True,
    )

@Client.on_message(filters.command('settings'))
async def settings(client, message):
    user_id = message.from_user.id if message.from_user else None
    if not user_id:
        return await message.reply(f" è·¥è·¥ú' Ä·¥á ·¥Ä…¥·¥è…¥ è·¥ç·¥è·¥úÍú± ·¥Ä·¥Ö·¥ç…™…¥.")
    chat_type = message.chat.type
    if chat_type in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        grp_id = message.chat.id
        if not await is_check_admin(client, grp_id, message.from_user.id):
            return await message.reply_text(script.NT_ADMIN_ALRT_TXT)
        await db.connect_group(grp_id, user_id)
        btn = [[
                InlineKeyboardButton("üë§ ·¥è·¥ò·¥á…¥ …™…¥ ·¥ò Ä…™·¥†·¥Ä·¥õ·¥á ·¥Ñ ú·¥Ä·¥õ üë§", callback_data=f"opnsetpm#{grp_id}")
              ],[
                InlineKeyboardButton("üë• ·¥è·¥ò·¥á…¥  ú·¥á Ä·¥á üë•", callback_data=f"opnsetgrp#{grp_id}")
              ]]
        await message.reply_text(
                text="<b>·¥° ú·¥á Ä·¥á ·¥Ö·¥è  è·¥è·¥ú ·¥°·¥Ä…¥·¥õ ·¥õ·¥è ·¥è·¥ò·¥á…¥ Íú±·¥á·¥õ·¥õ…™…¥…¢Íú± ·¥ç·¥á…¥·¥ú ? ‚öôÔ∏è</b>",
                reply_markup=InlineKeyboardMarkup(btn),
                disable_web_page_preview=True,
                parse_mode=enums.ParseMode.HTML,
                reply_to_message_id=message.id
        )
    elif chat_type == enums.ChatType.PRIVATE:
        connected_groups = await db.get_connected_grps(user_id)
        if not connected_groups:
            return await message.reply_text("N·¥è C·¥è…¥…¥·¥á·¥Ñ·¥õ·¥á·¥Ö G Ä·¥è·¥ú·¥òs F·¥è·¥ú…¥·¥Ö .")
        group_list = []
        for group in connected_groups:
            try:
                Chat = await client.get_chat(group)
                group_list.append([ InlineKeyboardButton(text=Chat.title, callback_data=f"grp_pm#{Chat.id}") ])
            except Exception as e:
                print(f"Error In PM Settings Button - {e}")
                pass
        await message.reply_text(
                    "‚ö†Ô∏è Íú±·¥á ü·¥á·¥Ñ·¥õ ·¥õ ú·¥á …¢ Ä·¥è·¥ú·¥ò ·¥° ú·¥èÍú±·¥á Íú±·¥á·¥õ·¥õ…™…¥…¢Íú±  è·¥è·¥ú ·¥°·¥Ä…¥·¥õ ·¥õ·¥è ·¥Ñ ú·¥Ä…¥…¢·¥á.\n\n"
                    "…™Íú∞  è·¥è·¥ú Ä …¢ Ä·¥è·¥ú·¥ò …™Íú± …¥·¥è·¥õ Íú± ú·¥è·¥°…™…¥…¢  ú·¥á Ä·¥á,\n"
                    "·¥úÍú±·¥á /reload …™…¥ ·¥õ ú·¥Ä·¥õ …¢ Ä·¥è·¥ú·¥ò ·¥Ä…¥·¥Ö …™·¥õ ·¥°…™ ü ü ·¥Ä·¥ò·¥ò·¥á·¥Ä Ä  ú·¥á Ä·¥á.",
                    reply_markup=InlineKeyboardMarkup(group_list)
                )
        
@Client.on_message(filters.command('reload'))
async def connect_group(client, message):
    user_id = message.from_user.id
    if message.chat.type in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        await db.connect_group(message.chat.id, user_id)
        await message.reply_text("G Ä·¥è·¥ú·¥ò R·¥á ü·¥è·¥Ä·¥Ö·¥á·¥Ö ‚úÖ N·¥è·¥° Y·¥è·¥ú C·¥Ä…¥ M·¥Ä…¥·¥Ä…¢·¥á T ú…™s G Ä·¥è·¥ú·¥ò F Ä·¥è·¥ç PM.")
    elif message.chat.type == enums.ChatType.PRIVATE:
        if len(message.command) < 2:
            await message.reply_text("Example: /reload 123456789")
            return
        try:
            group_id = int(message.command[1])
            if not await is_check_admin(client, group_id, user_id):
                await message.reply_text(script.NT_ADMIN_ALRT_TXT)
                return
            chat = await client.get_chat(group_id)
            await db.connect_group(group_id, user_id)
            await message.reply_text(f"L…™…¥·¥ã·¥á·¥Ö s·¥ú·¥Ñ·¥Ñ·¥áss“ì·¥ú ü ü è ‚úÖ {chat.title} ·¥õ·¥è PM.")
        except:
            await message.reply_text("Invalid group ID or error occurred.")
            
@Client.on_message(filters.command('set_template'))
async def save_template(client, message):
    sts = await message.reply("·¥Ñ ú·¥á·¥Ñ·¥ã…™…¥…¢ ·¥õ·¥á·¥ç·¥ò ü·¥Ä·¥õ·¥á...")
    user_id = message.from_user.id if message.from_user else None
    if not user_id:
        return await message.reply(" è·¥è·¥ú' Ä·¥á ·¥Ä…¥·¥è…¥ è·¥ç·¥è·¥úÍú± ·¥Ä·¥Ö·¥ç…™…¥.")
    
    if message.chat.type not in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        return await sts.edit("‚ö†Ô∏è ·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥ ·¥Ä …¢ Ä·¥è·¥ú·¥ò ·¥Ñ ú·¥Ä·¥õ.")
    
    group_id = message.chat.id
    title = message.chat.title
    if not await is_check_admin(client, group_id, user_id):
        await message.reply_text(script.NT_ADMIN_ALRT_TXT)
        return
    if len(message.command) < 2:
        return await sts.edit("‚ö†Ô∏è …¥·¥è ·¥õ·¥á·¥ç·¥ò ü·¥Ä·¥õ·¥á ·¥ò Ä·¥è·¥†…™·¥Ö·¥á·¥Ö!")
    
    template = message.text.split(" ", 1)[1]
    await save_group_settings(group_id, 'template', template)
    await sts.edit(
        f"‚úÖ Íú±·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü ü è ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥á·¥Ö ·¥õ·¥á·¥ç·¥ò ü·¥Ä·¥õ·¥á Íú∞·¥è Ä <code>{title}</code> ·¥õ·¥è:\n\n{template}"
    )


# Must add REQST_CHANNEL and SUPPORT_CHAT_ID to use this feature 
@Client.on_message((filters.command(["request", "Request"]) | filters.regex("#request") | filters.regex("#Request")) & filters.group)
async def requests(bot, message):
    if REQST_CHANNEL is None or SUPPORT_CHAT_ID is None: return 
    if message.reply_to_message and SUPPORT_CHAT_ID == message.chat.id:
        chat_id = message.chat.id
        reporter = str(message.from_user.id)
        mention = message.from_user.mention
        success = True
        content = message.reply_to_message.text
        try:
            if REQST_CHANNEL is not None:
                btn = [[
                        InlineKeyboardButton('·¥†…™·¥á·¥°  Ä·¥á«´·¥ú·¥áÍú±·¥õ', url=f"{message.reply_to_message.link}"),
                        InlineKeyboardButton('Íú± ú·¥è·¥° ·¥è·¥ò·¥õ…™·¥è…¥Íú±', callback_data=f'show_option#{reporter}')
                      ]]
                reported_post = await bot.send_message(chat_id=REQST_CHANNEL, text=f"<b>üìù  Ä·¥á«´·¥ú·¥áÍú±·¥õ : <u>{content}</u>\n\nüìö  Ä·¥á·¥ò·¥è Ä·¥õ·¥á·¥Ö  ô è : {mention}\nüìñ  Ä·¥á·¥ò·¥è Ä·¥õ·¥á Ä …™·¥Ö : {reporter}\n\n</b>", reply_markup=InlineKeyboardMarkup(btn))
                success = True
            elif len(content) >= 3:
                for admin in ADMINS:
                    btn = [[
                        InlineKeyboardButton('·¥†…™·¥á·¥°  Ä·¥á«´·¥ú·¥áÍú±·¥õ', url=f"{message.reply_to_message.link}"),
                        InlineKeyboardButton('Íú± ú·¥è·¥° ·¥è·¥ò·¥õ…™·¥è…¥Íú±', callback_data=f'show_option#{reporter}')
                      ]]
                    reported_post = await bot.send_message(chat_id=admin, text=f"<b>üìù  Ä·¥á«´·¥ú·¥áÍú±·¥õ : <u>{content}</u>\n\nüìö  Ä·¥á·¥ò·¥è Ä·¥õ·¥á·¥Ö  ô è : {mention}\nüìñ  Ä·¥á·¥ò·¥è Ä·¥õ·¥á Ä …™·¥Ö : {reporter}\n\n</b>", reply_markup=InlineKeyboardMarkup(btn))
                    success = True
            else:
                if len(content) < 3:
                    await message.reply_text("<b> è·¥è·¥ú ·¥ç·¥úÍú±·¥õ ·¥õ è·¥ò·¥á ·¥Ä ô·¥è·¥ú·¥õ  è·¥è·¥ú Ä  Ä·¥á«´·¥ú·¥áÍú±·¥õ [·¥ç…™…¥…™·¥ç·¥ú·¥ç 3 ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á ÄÍú±].  Ä·¥á«´·¥ú·¥áÍú±·¥õÍú± ·¥Ñ·¥Ä…¥'·¥õ  ô·¥á ·¥á·¥ç·¥ò·¥õ è.</b>")
            if len(content) < 3:
                success = False
        except Exception as e:
            await message.reply_text(f"Error: {e}")
            pass
    elif SUPPORT_CHAT_ID == message.chat.id:
        chat_id = message.chat.id
        reporter = str(message.from_user.id)
        mention = message.from_user.mention
        success = True
        content = message.text
        keywords = ["#request", "/request", "#Request", "/Request"]
        for keyword in keywords:
            if keyword in content:
                content = content.replace(keyword, "")
        try:
            if REQST_CHANNEL is not None and len(content) >= 3:
                btn = [[
                        InlineKeyboardButton('·¥†…™·¥á·¥°  Ä·¥á«´·¥ú·¥áÍú±·¥õ', url=f"{message.link}"),
                        InlineKeyboardButton('Íú± ú·¥è·¥° ·¥è·¥ò·¥õ…™·¥è…¥Íú±', callback_data=f'show_option#{reporter}')
                      ]]
                reported_post = await bot.send_message(chat_id=REQST_CHANNEL, text=f"<b>üìù  Ä·¥á«´·¥ú·¥áÍú±·¥õ : <u>{content}</u>\n\nüìö  Ä·¥á·¥ò·¥è Ä·¥õ·¥á·¥Ö  ô è : {mention}\nüìñ  Ä·¥á·¥ò·¥è Ä·¥õ·¥á Ä …™·¥Ö : {reporter}\n\n</b>", reply_markup=InlineKeyboardMarkup(btn))
                success = True
            elif len(content) >= 3:
                for admin in ADMINS:
                    btn = [[
                        InlineKeyboardButton('·¥†…™·¥á·¥°  Ä·¥á«´·¥ú·¥áÍú±·¥õ', url=f"{message.link}"),
                        InlineKeyboardButton('Íú± ú·¥è·¥° ·¥è·¥ò·¥õ…™·¥è…¥Íú±', callback_data=f'show_option#{reporter}')
                      ]]
                    reported_post = await bot.send_message(chat_id=admin, text=f"<b>üìù  Ä·¥á«´·¥ú·¥áÍú±·¥õ : <u>{content}</u>\n\nüìö  Ä·¥á·¥ò·¥è Ä·¥õ·¥á·¥Ö  ô è : {mention}\nüìñ  Ä·¥á·¥ò·¥è Ä·¥õ·¥á Ä …™·¥Ö : {reporter}\n\n</b>", reply_markup=InlineKeyboardMarkup(btn))
                    success = True
            else:
                if len(content) < 3:
                    await message.reply_text("<b> è·¥è·¥ú ·¥ç·¥úÍú±·¥õ ·¥õ è·¥ò·¥á ·¥Ä ô·¥è·¥ú·¥õ  è·¥è·¥ú Ä  Ä·¥á«´·¥ú·¥áÍú±·¥õ [·¥ç…™…¥…™·¥ç·¥ú·¥ç 3 ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á ÄÍú±].  Ä·¥á«´·¥ú·¥áÍú±·¥õÍú± ·¥Ñ·¥Ä…¥'·¥õ  ô·¥á ·¥á·¥ç·¥ò·¥õ è.</b>")
            if len(content) < 3:
                success = False
        except Exception as e:
            await message.reply_text(f"Error: {e}")
            pass
    elif SUPPORT_CHAT_ID == message.chat.id:
        chat_id = message.chat.id
        reporter = str(message.from_user.id)
        mention = message.from_user.mention
        success = True
        content = message.text
        keywords = ["#request", "/request", "#Request", "/Request"]
        for keyword in keywords:
            if keyword in content:
                content = content.replace(keyword, "")
        try:
            if REQST_CHANNEL is not None and len(content) >= 3:
                btn = [[
                        InlineKeyboardButton('·¥†…™·¥á·¥°  Ä·¥á«´·¥ú·¥áÍú±·¥õ', url=f"{message.link}"),
                        InlineKeyboardButton('Íú± ú·¥è·¥° ·¥è·¥ò·¥õ…™·¥è…¥Íú±', callback_data=f'show_option#{reporter}')
                      ]]
                reported_post = await bot.send_message(chat_id=REQST_CHANNEL, text=f"<b>üìù  Ä·¥á«´·¥ú·¥áÍú±·¥õ : <u>{content}</u>\n\nüìö  Ä·¥á·¥ò·¥è Ä·¥õ·¥á·¥Ö  ô è : {mention}\nüìñ  Ä·¥á·¥ò·¥è Ä·¥õ·¥á Ä …™·¥Ö : {reporter}\n\n</b>", reply_markup=InlineKeyboardMarkup(btn))
                success = True
            elif len(content) >= 3:
                for admin in ADMINS:
                    btn = [[
                        InlineKeyboardButton('·¥†…™·¥á·¥°  Ä·¥á«´·¥ú·¥áÍú±·¥õ', url=f"{message.link}"),
                        InlineKeyboardButton('Íú± ú·¥è·¥° ·¥è·¥ò·¥õ…™·¥è…¥Íú±', callback_data=f'show_option#{reporter}')
                      ]]
                    reported_post = await bot.send_message(chat_id=admin, text=f"<b>üìù  Ä·¥á«´·¥ú·¥áÍú±·¥õ : <u>{content}</u>\n\nüìö  Ä·¥á·¥ò·¥è Ä·¥õ·¥á·¥Ö  ô è : {mention}\nüìñ  Ä·¥á·¥ò·¥è Ä·¥õ·¥á Ä …™·¥Ö : {reporter}\n\n</b>", reply_markup=InlineKeyboardMarkup(btn))
                    success = True
            else:
                if len(content) < 3:
                    await message.reply_text("<b> è·¥è·¥ú ·¥ç·¥úÍú±·¥õ ·¥õ è·¥ò·¥á ·¥Ä ô·¥è·¥ú·¥õ  è·¥è·¥ú Ä  Ä·¥á«´·¥ú·¥áÍú±·¥õ [·¥ç…™…¥…™·¥ç·¥ú·¥ç 3 ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á ÄÍú±].  Ä·¥á«´·¥ú·¥áÍú±·¥õÍú± ·¥Ñ·¥Ä…¥'·¥õ  ô·¥á ·¥á·¥ç·¥ò·¥õ è.</b>")
            if len(content) < 3:
                success = False
        except Exception as e:
            await message.reply_text(f"Error: {e}")
            pass
    else:
        success = False
    if success:
        '''if isinstance(REQST_CHANNEL, (int, str)):
            channels = [REQST_CHANNEL]
        elif isinstance(REQST_CHANNEL, list):
            channels = REQST_CHANNEL
        for channel in channels:
            chat = await bot.get_chat(channel)
        #chat = int(chat)'''
        link = await bot.create_chat_invite_link(int(REQST_CHANNEL))
        btn = [[
                InlineKeyboardButton('·¥ä·¥è…™…¥ ·¥Ñ ú·¥Ä…¥…¥·¥á ü', url=link.invite_link),
                InlineKeyboardButton('·¥†…™·¥á·¥°  Ä·¥á«´·¥ú·¥áÍú±·¥õ', url=f"{reported_post.link}")
              ]]
        await message.reply_text("<b> è·¥è·¥ú Ä  Ä·¥á«´·¥ú·¥áÍú±·¥õ  ú·¥ÄÍú±  ô·¥á·¥á…¥ ·¥Ä·¥Ö·¥Ö·¥á·¥Ö! ·¥ò ü·¥á·¥ÄÍú±·¥á ·¥°·¥Ä…™·¥õ Íú∞·¥è Ä Íú±·¥è·¥ç·¥á ·¥õ…™·¥ç·¥á.\n\n·¥ä·¥è…™…¥ ·¥Ñ ú·¥Ä…¥…¥·¥á ü Íú∞…™ ÄÍú±·¥õ & ·¥†…™·¥á·¥°  Ä·¥á«´·¥ú·¥áÍú±·¥õ.</b>", reply_markup=InlineKeyboardMarkup(btn))
    
@Client.on_message(filters.command("send") & filters.user(ADMINS))
async def send_msg(bot, message):
    if message.reply_to_message:
        target_id = message.text.split(" ", 1)[1]
        out = "Users Saved In DB Are:\n\n"
        success = False
        try:
            user = await bot.get_users(target_id)
            users = await db.get_all_users()
            async for usr in users:
                out += f"{usr['id']}"
                out += '\n'
            if str(user.id) in str(out):
                await message.reply_to_message.copy(int(user.id))
                success = True
            else:
                success = False
            if success:
                await message.reply_text(f"<b> è·¥è·¥ú Ä ·¥ç·¥áÍú±Íú±·¥Ä…¢·¥á  ú·¥ÄÍú±  ô·¥á·¥á…¥ Íú±·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü ü è Íú±·¥á…¥·¥õ ·¥õ·¥è {user.mention}.</b>")
            else:
                await message.reply_text("<b>·¥õ ú…™Íú± ·¥úÍú±·¥á Ä ·¥Ö…™·¥Ö…¥'·¥õ Íú±·¥õ·¥Ä Ä·¥õ·¥á·¥Ö ·¥õ ú…™Íú±  ô·¥è·¥õ  è·¥á·¥õ !</b>")
        except Exception as e:
            await message.reply_text(f"<b>Error: {e}</b>")
    else:
        await message.reply_text("<b>·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö ·¥ÄÍú± ·¥Ä  Ä·¥á·¥ò ü è ·¥õ·¥è ·¥Ä…¥ è ·¥ç·¥áÍú±Íú±·¥Ä…¢·¥á ·¥úÍú±…™…¥…¢ ·¥õ ú·¥á ·¥õ·¥Ä Ä…¢·¥á·¥õ ·¥Ñ ú·¥Ä·¥õ …™·¥Ö. Íú∞·¥è Ä ·¥á…¢:  /send ·¥úÍú±·¥á Ä…™·¥Ö</b>")

@Client.on_message(filters.command("deletefiles") & filters.user(ADMINS))
async def deletemultiplefiles(bot, message):
    chat_type = message.chat.type
    if chat_type != enums.ChatType.PRIVATE:
        return await message.reply_text(f"<b>Hey {message.from_user.mention}, This command won't work in groups. It only works on my PM !</b>")
    else:
        pass
    try:
        keyword = message.text.split(" ", 1)[1]
    except:
        return await message.reply_text(f"<b>Hey {message.from_user.mention}, Give me a keyword along with the command to delete files.</b>")
    k = await bot.send_message(chat_id=message.chat.id, text=f"<b>Fetching Files for your query {keyword} on DB... Please wait...</b>")
    files, total = await get_bad_files(keyword)
    await k.delete()
    btn = [[
       InlineKeyboardButton("‚ö†Ô∏è Yes, Continue ! ‚ö†Ô∏è", callback_data=f"killfilesdq#{keyword}")
       ],[
       InlineKeyboardButton("‚ùå No, Abort operation ! ‚ùå", callback_data="close_data")
    ]]
    await message.reply_text(
        text=f"<b>Found {total} files for your query {keyword} !\n\nDo you want to delete?</b>",
        reply_markup=InlineKeyboardMarkup(btn),
        parse_mode=enums.ParseMode.HTML
    )


@Client.on_callback_query(filters.regex("topsearch"))
async def topsearch_callback(client, callback_query):
    def is_alphanumeric(string):
        return bool(re.match('^[a-zA-Z0-9 ]*$', string))
    
    limit = 20  
    top_messages = await mdb.get_top_messages(limit)
    seen_messages = set()
    truncated_messages = []
    for msg in top_messages:
        msg_lower = msg.lower()
        if msg_lower not in seen_messages and is_alphanumeric(msg):
            seen_messages.add(msg_lower)
            if len(msg) > 35:
                truncated_messages.append(msg[:32] + "...")
            else:
                truncated_messages.append(msg)
    keyboard = [truncated_messages[i:i+2] for i in range(0, len(truncated_messages), 2)]
    reply_markup = ReplyKeyboardMarkup(
        keyboard, 
        one_time_keyboard=True, 
        resize_keyboard=True, 
        placeholder="Most searches of the day"
    )
    await callback_query.message.reply_text(
        "<b>T·¥è·¥ò S·¥á·¥Ä Ä·¥Ñ ú·¥ás O“ì T ú·¥á D·¥Ä è üëá</b>",
        reply_markup=reply_markup
    )
    await callback_query.answer()

@Client.on_message(filters.command('top_search'))
async def top(_, message):
    def is_alphanumeric(string):
        return bool(re.match('^[a-zA-Z0-9 ]*$', string))
    try:
        limit = int(message.command[1])
    except (IndexError, ValueError):
        limit = 20
    top_messages = await mdb.get_top_messages(limit)
    seen_messages = set()
    truncated_messages = []
    for msg in top_messages:
        msg_lower = msg.lower()
        if msg_lower not in seen_messages and is_alphanumeric(msg):
            seen_messages.add(msg_lower)
            if len(msg) > 35:
                truncated_messages.append(msg[:32] + "...")
            else:
                truncated_messages.append(msg)
    keyboard = [truncated_messages[i:i+2] for i in range(0, len(truncated_messages), 2)]
    reply_markup = ReplyKeyboardMarkup(
        keyboard, 
        one_time_keyboard=True, 
        resize_keyboard=True, 
        placeholder="Most searches of the day"
    )
    await message.reply_text(
        "<b>T·¥è·¥ò S·¥á·¥Ä Ä·¥Ñ ú·¥ás O“ì T ú·¥á D·¥Ä è üëá</b>",
        reply_markup=reply_markup
    )

@Client.on_message(filters.command('trendlist'))
async def trendlist(client, message):
    def is_alphanumeric(string):
        return bool(re.match('^[a-zA-Z0-9 ]*$', string))
    limit = 31
    if len(message.command) > 1:
        try:
            limit = int(message.command[1])
        except ValueError:
            await message.reply_text(
                "Invalid number format.\nPlease provide a valid number after the /trendlist command."
            )
            return 
    try:
        top_messages = await mdb.get_top_messages(limit)
    except Exception as e:
        await message.reply_text(f"Error retrieving messages: {str(e)}")
        return  

    if not top_messages:
        await message.reply_text("No top messages found.")
        return 
    seen_messages = set()
    truncated_messages = []

    for msg in top_messages:
        msg_lower = msg.lower()
        if msg_lower not in seen_messages and is_alphanumeric(msg):
            seen_messages.add(msg_lower)
            truncated_messages.append(msg[:32] + '...' if len(msg) > 35 else msg)

    if not truncated_messages:
        await message.reply_text("No valid top messages found.")
        return  
    formatted_list = "\n".join([f"{i+1}. <b>{msg}</b>" for i, msg in enumerate(truncated_messages)])
    additional_message = (
        "‚ö°Ô∏è ùë®ùíçùíç ùíïùíâùíÜ ùíìùíÜùíîùíñùíçùíïùíî ùíÇùíÉùíêùíóùíÜ ùíÑùíêùíéùíÜ ùíáùíìùíêùíé ùíòùíâùíÇùíï ùíñùíîùíÜùíìùíî ùíâùíÇùíóùíÜ ùíîùíÜùíÇùíìùíÑùíâùíÜùíÖ ùíáùíêùíì. "
        "ùëªùíâùíÜùíö'ùíìùíÜ ùíîùíâùíêùíòùíè ùíïùíê ùíöùíêùíñ ùíÜùíôùíÇùíÑùíïùíçùíö ùíÇùíî ùíïùíâùíÜùíö ùíòùíÜùíìùíÜ ùíîùíÜùíÇùíìùíÑùíâùíÜùíÖ, "
        "ùíòùíäùíïùíâùíêùíñùíï ùíÇùíèùíö ùíÑùíâùíÇùíèùíàùíÜùíî ùíÉùíö ùíïùíâùíÜ ùíêùíòùíèùíÜùíì."
    )
    formatted_list += f"\n\n{additional_message}"
    reply_text = f"<b>Top {len(truncated_messages)} T Ä·¥Ä…¥·¥Ö…™…¥…¢ ·¥è“ì ·¥õ ú·¥á ·¥Ö·¥Ä è üëá:</b>\n\n{formatted_list}"
    await message.reply_text(reply_text)

@Client.on_message(filters.private & filters.command("pm_search") & filters.user(ADMINS))
async def set_pm_search(client, message):
    bot_id = client.me.id
    try:
        option = message.text.split(" ", 1)[1].strip().lower()
        enable_status = option in ['on', 'true']
    except (IndexError, ValueError):
        await message.reply_text("<b>üíî Invalid option. Please send 'on' or 'off' after the command..</b>")
        return
    try:
        await db.update_pm_search_status(bot_id, enable_status)
        response_text = (
            "<b> ·¥ò·¥ç Íú±·¥á·¥Ä Ä·¥Ñ ú ·¥á…¥·¥Ä ô ü·¥á·¥Ö ‚úÖ</b>" if enable_status 
            else "<b> ·¥ò·¥ç Íú±·¥á·¥Ä Ä·¥Ñ ú ·¥Ö…™Íú±·¥Ä ô ü·¥á·¥Ö ‚ùå</b>"
        )
        await message.reply_text(response_text)
    except Exception as e:
        logger.error(f"Error in set_pm_search: {e}")
        await message.reply_text(f"<b>‚ùó An error occurred: {e}</b>")

@Client.on_message(filters.private & filters.command("movie_update") & filters.user(ADMINS))
async def set_movie_update_notification(client, message):
    bot_id = client.me.id
    try:
        option = message.text.split(" ", 1)[1].strip().lower()
        enable_status = option in ['on', 'true']
    except (IndexError, ValueError):
        await message.reply_text("<b>üíî Invalid option. Please send 'on' or 'off' after the command.</b>")
        return
    try:
        await db.update_movie_update_status(bot_id, enable_status)
        response_text = (
            "<b>·¥ç·¥è·¥†…™·¥á ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥á …¥·¥è·¥õ…™Íú∞…™·¥Ñ·¥Ä·¥õ…™·¥è…¥ ·¥á…¥·¥Ä ô ü·¥á·¥Ö ‚úÖ</b>" if enable_status 
            else "<b>·¥ç·¥è·¥†…™·¥á ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥á …¥·¥è·¥õ…™Íú∞…™·¥Ñ·¥Ä·¥õ…™·¥è…¥ ·¥Ö…™Íú±·¥Ä ô ü·¥á·¥Ö ‚ùå</b>"
        )
        await message.reply_text(response_text)
    except Exception as e:
        logger.error(f"Error in set_movie_update_notification: {e}")
        await message.reply_text(f"<b>‚ùó An error occurred: {e}</b>")

@Client.on_message(filters.command("restart") & filters.user(ADMINS))
async def stop_button(bot, message):
    msg = await bot.send_message(text="<b><i> ô·¥è·¥õ …™Íú±  Ä·¥áÍú±·¥õ·¥Ä Ä·¥õ…™…¥…¢</i></b>", chat_id=message.chat.id)       
    await asyncio.sleep(3)
    await msg.edit("<b><i><u> ô·¥è·¥õ …™Íú±  Ä·¥áÍú±·¥õ·¥Ä Ä·¥õ·¥á·¥Ö</u> ‚úÖ</i></b>")
    os.execl(sys.executable, sys.executable, *sys.argv)

@Client.on_message(filters.command("del_msg") & filters.user(ADMINS))
async def del_msg(client, message):
    confirm_markup = InlineKeyboardMarkup([[
        InlineKeyboardButton("Yes", callback_data="confirm_del_yes"),
        InlineKeyboardButton("No", callback_data="confirm_del_no")
    ]])
    sent_message = await message.reply_text(
        "‚ö†Ô∏è A Ä·¥á  è·¥è·¥ú s·¥ú Ä·¥á  è·¥è·¥ú ·¥°·¥Ä…¥·¥õ ·¥õ·¥è ·¥Ñ ü·¥á·¥Ä Ä ·¥õ ú·¥á ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥ás ·¥Ñ ú·¥Ä…¥…¥·¥á ü  ü…™s·¥õ ?\n\n ·¥Ö·¥è  è·¥è·¥ú Íú±·¥õ…™ ü ü ·¥°·¥Ä…¥·¥õ ·¥õ·¥è ·¥Ñ·¥è…¥·¥õ…™…¥·¥ú·¥á ?",
        reply_markup=confirm_markup
    )
    await asyncio.sleep(60)
    try:
        await sent_message.delete()
    except Exception as e:
        print(f"Error deleting the message: {e}")

@Client.on_callback_query(filters.regex('^confirm_del_'))
async def confirmation_handler(client, callback_query):
    action = callback_query.data.split("_")[-1] 
    if action == "yes":
        await db.delete_all_msg()  
        await callback_query.message.edit_text('üßπ ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥áÍú± ·¥Ñ ú·¥Ä…¥…¥·¥á ü  ü…™s·¥õ  ú·¥Äs  ô·¥á·¥á…¥ ·¥Ñ ü·¥á·¥Ä Ä·¥á·¥Ö s·¥ú·¥Ñ·¥Ñ·¥áss“ì·¥ú ü ü è ‚úÖ')
    elif action == "no":
        await callback_query.message.delete()  
    await callback_query.answer()

@Client.on_message(filters.command('set_caption'))
async def save_caption(client, message):
    grp_id = message.chat.id
    title = message.chat.title
    invite_link = await client.export_chat_invite_link(grp_id)
    if not await is_check_admin(client, grp_id, message.from_user.id):
        return await message.reply_text(script.NT_ADMIN_ALRT_TXT)
    chat_type = message.chat.type
    if chat_type not in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        return await message.reply_text("<b>·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥ …¢ Ä·¥è·¥ú·¥ò...</b>")
    try:
        caption = message.text.split(" ", 1)[1]
    except:
        return await message.reply_text("<code>…¢…™·¥†·¥á ·¥ç·¥á ·¥Ä ·¥Ñ·¥Ä·¥ò·¥õ…™·¥è…¥ ·¥Ä ü·¥è…¥…¢ ·¥°…™·¥õ ú …™·¥õ.\n\n·¥áx·¥Ä·¥ç·¥ò ü·¥á -\n\nÍú∞·¥è Ä Íú∞…™ ü·¥á …¥·¥Ä·¥ç·¥á Íú±·¥á…¥·¥Ö <code>{file_name}</code>\nÍú∞·¥è Ä Íú∞…™ ü·¥á Íú±…™·¥¢·¥á Íú±·¥á…¥·¥Ö <code>{file_size}</code>\n\n<code>/set_caption {file_name}</code></code>")
    await save_group_settings(grp_id, 'caption', caption)
    await message.reply_text(f"Íú±·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü ü è ·¥Ñ ú·¥Ä…¥…¢·¥á·¥Ö ·¥Ñ·¥Ä·¥ò·¥õ…™·¥è…¥ Íú∞·¥è Ä {title}\n\n·¥Ñ·¥Ä·¥ò·¥õ…™·¥è…¥ - {caption}", disable_web_page_preview=True)
    await client.send_message(LOG_API_CHANNEL, f"#Set_Caption\n\n…¢ Ä·¥è·¥ú·¥ò …¥·¥Ä·¥ç·¥á : {title}\n\n…¢ Ä·¥è·¥ú·¥ò …™·¥Ö: {grp_id}\n…™…¥·¥†…™·¥õ·¥á  ü…™…¥·¥ã : {invite_link}\n\n·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥á·¥Ö  ô è : {message.from_user.username}")


@Client.on_message(filters.command(["set_tutorial", "set_tutorial_2", "set_tutorial_3"]))
async def set_tutorial(client, message: Message):
    grp_id = message.chat.id
    title = message.chat.title
    chat_type = message.chat.type
    if chat_type not in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        return await message.reply_text(
            f"<b>·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥ …¢ Ä·¥è·¥ú·¥ò...\n\nGroup Name: {title}\nGroup ID: {grp_id}</b>"
        )
    if not await is_check_admin(client, grp_id, message.from_user.id):
        return await message.reply_text(script.NT_ADMIN_ALRT_TXT)

    try:
        tutorial_link = message.text.split(" ", 1)[1]
    except IndexError:
        return await message.reply_text(
            f"<b>·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥·¥Ñ·¥è·¥ç·¥ò ü·¥á·¥õ·¥á !!\n\n·¥úÍú±·¥á  ü…™·¥ã·¥á ·¥õ ú…™Íú± -</b>\n\n"
            f"<code>/{message.command[0]} https://t.me/dreamxbotz</code>"
        )
    if message.command[0] == "set_tutorial":
        tutorial_key = "tutorial"
    else:
        tutorial_key = f"tutorial_{message.command[0].split('_', 2)[2]}"

    await save_group_settings(grp_id, tutorial_key, tutorial_link)
    invite_link = await client.export_chat_invite_link(grp_id)
    await message.reply_text(
        f"<b>Íú±·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü ü è ·¥Ñ ú·¥Ä…¥…¢·¥á·¥Ö {tutorial_key.replace('_', ' ').title()} Íú∞·¥è Ä {title}</b>\n\n"
        f" ü…™…¥·¥ã - {tutorial_link}",
        disable_web_page_preview=True
    )
    await client.send_message(
        LOG_API_CHANNEL,
        f"#Set_{tutorial_key.title()}_Video\n\n"
        f"…¢ Ä·¥è·¥ú·¥ò …¥·¥Ä·¥ç·¥á : {title}\n"
        f"…¢ Ä·¥è·¥ú·¥ò …™·¥Ö : {grp_id}\n"
        f"…™…¥·¥†…™·¥õ·¥á  ü…™…¥·¥ã : {invite_link}\n"
        f"·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥á·¥Ö  ô è : {message.from_user.mention()}"
    )


async def handle_shortner_command(c, m, shortner_key, api_key, log_prefix, fallback_url, fallback_api):
    grp_id = m.chat.id
    if not await is_check_admin(c, grp_id, m.from_user.id):
        return await m.reply_text(script.NT_ADMIN_ALRT_TXT)
    if len(m.command) != 3:
        return await m.reply(
            f"<b>·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö  ü…™·¥ã·¥á -\n\n`/{m.command[0]} vplink.in your_api_key_here`</b>"
        )
    sts = await m.reply("<b>‚ôªÔ∏è ·¥Ñ ú·¥á·¥Ñ·¥ã…™…¥…¢...</b>")
    await asyncio.sleep(1.2)
    await sts.delete()
    if m.chat.type not in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        return await m.reply_text("<b>·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥ …¢ Ä·¥è·¥ú·¥ò...</b>")
    try:
        URL = m.command[1]
        API = m.command[2]
        await save_group_settings(grp_id, shortner_key, URL)
        await save_group_settings(grp_id, api_key, API)
        await m.reply_text(f"<b><u>‚úÖ s ú·¥è Ä·¥õ…¥·¥á Ä ·¥Ä·¥Ö·¥Ö·¥á·¥Ö</u>\n\nÍú±…™·¥õ·¥á - `{URL}`\n·¥Ä·¥ò…™ - `{API}`</b>")
        user_id = m.from_user.id
        user_info = f"@{m.from_user.username}" if m.from_user.username else f"{m.from_user.mention}"
        link = (await c.get_chat(m.chat.id)).invite_link
        grp_link = f"[{m.chat.title}]({link})"
        log_message = (
            f"#{log_prefix}\n\n…¥·¥Ä·¥ç·¥á - {user_info}\n\n…™·¥Ö - `{user_id}`"
            f"\n\nÍú±…™·¥õ·¥á - {URL}\n\n·¥Ä·¥ò…™ - `{API}`"
            f"\n\n…¢ Ä·¥è·¥ú·¥ò - {grp_link}\n…¢ Ä·¥è·¥ú·¥ò …™·¥Ö - `{grp_id}`"
        )
        await c.send_message(LOG_API_CHANNEL, log_message, disable_web_page_preview=True)
    except Exception as e:
        await save_group_settings(grp_id, shortner_key, fallback_url)
        await save_group_settings(grp_id, api_key, fallback_api)
        await m.reply_text(
            f"<b><u>üí¢ ·¥á Ä Ä·¥è Ä ·¥è·¥Ñ·¥Ñ·¥ú Ä·¥á·¥Ö!</u>\n\n"
            f"·¥Ö·¥áÍú∞·¥Ä·¥ú ü·¥õ Íú± ú·¥è Ä·¥õ…¥·¥á Ä ·¥Ä·¥ò·¥ò ü…™·¥á·¥Ö\n"
            f"…™Íú∞  è·¥è·¥ú ·¥°·¥Ä…¥·¥õ ·¥õ·¥è ·¥Ñ ú·¥Ä…¥…¢·¥á ·¥õ Ä è ·¥Ä ·¥†·¥Ä ü…™·¥Ö Íú±…™·¥õ·¥á ·¥Ä…¥·¥Ö ·¥Ä·¥ò…™ ·¥ã·¥á è.\n\n"
            f" ü…™·¥ã·¥á:\n\n`/{m.command[0]} vplink.in your_api_key_here`\n\n"
            f"üíî ·¥á Ä Ä·¥è Ä - <code>{e}</code></b>"
        )

@Client.on_message(filters.command('set_shortner'))
async def set_shortner(c, m):
    await handle_shortner_command(c, m, 'shortner', 'api', 'New_Shortner_Set_For_1st_Verify', SHORTENER_WEBSITE, SHORTENER_API)

@Client.on_message(filters.command('set_shortner_2'))
async def set_shortner_2(c, m):
    await handle_shortner_command(c, m, 'shortner_two', 'api_two', 'New_Shortner_Set_For_2nd_Verify', SHORTENER_WEBSITE2, SHORTENER_API2)

@Client.on_message(filters.command('set_shortner_3'))
async def set_shortner_3(c, m):
    await handle_shortner_command(c, m, 'shortner_three', 'api_three', 'New_Shortner_Set_For_3rd_Verify', SHORTENER_WEBSITE3, SHORTENER_API3)

@Client.on_message(filters.command('set_log_channel'))
async def set_log(client, message):
    grp_id = message.chat.id
    title = message.chat.title
    if not await is_check_admin(client, grp_id, message.from_user.id):
        return await message.reply_text(script.NT_ADMIN_ALRT_TXT)
    if len(message.text.split()) == 1:
        await message.reply("<b>·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö  ü…™·¥ã·¥á ·¥õ ú…™Íú± - \n\n`/set_log_channel -100******`</b>")
        return
    sts = await message.reply("<b>‚ôªÔ∏è ·¥Ñ ú·¥á·¥Ñ·¥ã…™…¥…¢...</b>")
    await asyncio.sleep(1.2)
    await sts.delete()
    chat_type = message.chat.type
    if chat_type not in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        return await message.reply_text("<b>·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥ …¢ Ä·¥è·¥ú·¥ò...</b>")
    try:
        log = int(message.text.split(" ", 1)[1])
    except IndexError:
        return await message.reply_text("<b><u>…™…¥·¥†·¥Ä…™ ü·¥Ö Íú∞·¥è Ä·¥ç·¥Ä·¥õ!!</u>\n\n·¥ús·¥á  ü…™·¥ã·¥á ·¥õ ú…™s - `/set_log_channel -100xxxxxxxx`</b>")
    except ValueError:
        return await message.reply_text('<b>·¥ç·¥Ä·¥ã·¥á s·¥ú Ä·¥á …™·¥Ö …™s …™…¥·¥õ·¥á…¢·¥á Ä...</b>')
    try:
        t = await client.send_message(chat_id=log, text="<b> ú·¥á è ·¥° ú·¥Ä·¥õ's ·¥ú·¥ò!!</b>")
        await asyncio.sleep(3)
        await t.delete()
    except Exception as e:
        return await message.reply_text(f'<b><u>üòê ·¥ç·¥Ä·¥ã·¥á s·¥ú Ä·¥á ·¥õ ú…™s  ô·¥è·¥õ ·¥Ä·¥Ö·¥ç…™…¥ …™…¥ ·¥õ ú·¥Ä·¥õ ·¥Ñ ú·¥Ä…¥…¥·¥á ü...</u>\n\nüíî ·¥á Ä Ä·¥è Ä - <code>{e}</code></b>')
    await save_group_settings(grp_id, 'log', log)
    await message.reply_text(f"<b>‚úÖ s·¥ú·¥Ñ·¥Ñ·¥ássÍú∞·¥ú ü ü è s·¥á·¥õ  è·¥è·¥ú Ä  ü·¥è…¢ ·¥Ñ ú·¥Ä…¥…¥·¥á ü Íú∞·¥è Ä {title}\n\n…™·¥Ö - `{log}`</b>", disable_web_page_preview=True)
    user_id = message.from_user.id
    user_info = f"@{message.from_user.username}" if message.from_user.username else f"{message.from_user.mention}"
    link = (await client.get_chat(message.chat.id)).invite_link
    grp_link = f"[{message.chat.title}]({link})"
    log_message = f"#New_Log_Channel_Set\n\n…¥·¥Ä·¥ç·¥á - {user_info}\n\n…™·¥Ö - `{user_id}`\n\n ü·¥è…¢ ·¥Ñ ú·¥Ä…¥…¥·¥á ü …™·¥Ö - `{log}`\n…¢ Ä·¥è·¥ú·¥ò  ü…™…¥·¥ã - `{grp_link}`\n\n…¢ Ä·¥è·¥ú·¥ò …™·¥Ö : `{grp_id}`"
    await client.send_message(LOG_API_CHANNEL, log_message, disable_web_page_preview=True) 


@Client.on_message(filters.command('set_time'))
async def set_time(client, message):
    chat_type = message.chat.type
    if chat_type not in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        return await message.reply_text("<b>·¥ús·¥á ·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥ …¢ Ä·¥è·¥ú·¥ò...</b>")       
    grp_id = message.chat.id
    title = message.chat.title
    invite_link = await client.export_chat_invite_link(grp_id)
    if not await is_check_admin(client, grp_id, message.from_user.id):
        return await message.reply_text(script.NT_ADMIN_ALRT_TXT)
    try:
        time = int(message.text.split(" ", 1)[1])
    except:
        return await message.reply_text("<b>·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥·¥Ñ·¥è·¥ç·¥ò ü·¥á·¥õ·¥á\n\n·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö  ü…™·¥ã·¥á ·¥õ ú…™Íú± - <code>/set_time 600</code> [ ·¥õ…™·¥ç·¥á ·¥ç·¥úÍú±·¥õ  ô·¥á …™…¥ Íú±·¥á·¥Ñ·¥è…¥·¥ÖÍú± ]</b>")   
    await save_group_settings(grp_id, 'verify_time', time)
    await message.reply_text(f"<b>‚úÖÔ∏è Íú±·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü ü è Íú±·¥á·¥õ 2…¥·¥Ö ·¥†·¥á Ä…™Íú∞ è ·¥õ…™·¥ç·¥á Íú∞·¥è Ä {title}\n\n·¥õ…™·¥ç·¥á - <code>{time}</code></b>")
    await client.send_message(LOG_API_CHANNEL, f"#Set_2nd_Verify_Time\n\n…¢ Ä·¥è·¥ú·¥ò …¥·¥Ä·¥ç·¥á : {title}\n\n…¢ Ä·¥è·¥ú·¥ò …™·¥Ö : {grp_id}\n\n…™…¥·¥†…™·¥õ·¥á  ü…™…¥·¥ã : {invite_link}\n\n·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥á·¥Ö  ô è : {message.from_user.username}")

@Client.on_message(filters.command('set_time_2'))
async def set_time_2(client, message):
    chat_type = message.chat.type
    if chat_type not in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        return await message.reply_text("<b>·¥ús·¥á ·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥ …¢ Ä·¥è·¥ú·¥ò...</b>")       
    grp_id = message.chat.id
    title = message.chat.title
    invite_link = await client.export_chat_invite_link(grp_id)
    if not await is_check_admin(client, grp_id, message.from_user.id):
        return await message.reply_text(script.NT_ADMIN_ALRT_TXT)
    try:
        time = int(message.text.split(" ", 1)[1])
    except:
        return await message.reply_text("<b>·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥·¥Ñ·¥è·¥ç·¥ò ü·¥á·¥õ·¥á\n\n·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö  ü…™·¥ã·¥á ·¥õ ú…™Íú± - <code>/set_time 3600</code> [ ·¥õ…™·¥ç·¥á ·¥ç·¥úÍú±·¥õ  ô·¥á …™…¥ Íú±·¥á·¥Ñ·¥è…¥·¥ÖÍú± ]</b>")   
    await save_group_settings(grp_id, 'third_verify_time', time)
    await message.reply_text(f"<b>‚úÖÔ∏è Íú±·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü ü è Íú±·¥á·¥õ 3 Ä·¥Ö ·¥†·¥á Ä…™Íú∞ è ·¥õ…™·¥ç·¥á Íú∞·¥è Ä {title}\n\n·¥õ…™·¥ç·¥á - <code>{time}</code></b>")
    await client.send_message(LOG_API_CHANNEL, f"#Set_3rd_Verify_Time\n\n…¢ Ä·¥è·¥ú·¥ò …¥·¥Ä·¥ç·¥á : {title}\n\n…¢ Ä·¥è·¥ú·¥ò …™·¥Ö : {grp_id}\n\n…™…¥·¥†…™·¥õ·¥á  ü…™…¥·¥ã : {invite_link}\n\n·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥á·¥Ö  ô è : {message.from_user.username}")


@Client.on_message(filters.command('details'))
async def all_settings(client, message):
    if message.chat.type not in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        return await message.reply_text("<b>·¥ús·¥á ·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥ …¢ Ä·¥è·¥ú·¥ò...</b>")
    grp_id = message.chat.id
    title = message.chat.title
    if not await is_check_admin(client, grp_id, message.from_user.id):
        return await message.reply_text(script.NT_ADMIN_ALRT_TXT)
    try:
        settings = await get_settings(grp_id)
    except Exception as e:
        return await message.reply_text(f"<b>‚ö†Ô∏è ·¥á Ä Ä·¥è Ä Íú∞·¥á·¥õ·¥Ñ ú…™…¥…¢ Íú±·¥á·¥õ·¥õ…™…¥…¢Íú±:</b>\n<code>{e}</code>")
    text = generate_settings_text(settings, title)
    btn = [
        [InlineKeyboardButton("‚ôªÔ∏è  Ä·¥áÍú±·¥á·¥õ Íú±·¥á·¥õ·¥õ…™…¥…¢Íú±", callback_data=f"reset_group_{grp_id}")],
        [InlineKeyboardButton("üö´ ·¥Ñ ü·¥èÍú±·¥á", callback_data="close_data")]
    ]
    dlt = await message.reply_text(text, reply_markup=InlineKeyboardMarkup(btn), disable_web_page_preview=True)
    await asyncio.sleep(300)
    await dlt.delete()

@Client.on_callback_query(filters.regex(r"^reset_group_(\-\d+)$"))
async def reset_group_callback(client, callback_query):
    grp_id = int(callback_query.matches[0].group(1))
    user_id = callback_query.from_user.id
    if not await is_check_admin(client, grp_id, user_id):
        return await callback_query.answer(script.NT_ADMIN_ALRT_TXT, show_alert=True)
    await callback_query.answer("‚ôªÔ∏è  Ä·¥áÍú±·¥á·¥õ·¥õ…™…¥…¢ Íú±·¥á·¥õ·¥õ…™…¥…¢Íú±...")
    defaults = {
        'shortner': SHORTENER_WEBSITE,
        'api': SHORTENER_API,
        'shortner_two': SHORTENER_WEBSITE2,
        'api_two': SHORTENER_API2,
        'shortner_three': SHORTENER_WEBSITE3,
        'api_three': SHORTENER_API3,
        'verify_time': TWO_VERIFY_GAP,
        'third_verify_time': THREE_VERIFY_GAP,
        'template': IMDB_TEMPLATE,
        'tutorial': TUTORIAL,
        'tutorial_2': TUTORIAL_2,
        'tutorial_3': TUTORIAL_3,
        'caption': CUSTOM_FILE_CAPTION,
        'log': LOG_CHANNEL,
        'is_verify': IS_VERIFY,
        'fsub': AUTH_CHANNELS,
        'reqfsub': AUTH_REQ_CHANNELS
    }
    current = await get_settings(grp_id)
    if current == defaults:
        return await callback_query.answer("‚úÖ Íú±·¥á·¥õ·¥õ…™…¥…¢Íú± ·¥Ä ü Ä·¥á·¥Ä·¥Ö è ·¥Ö·¥áÍú∞·¥Ä·¥ú ü·¥õ.", show_alert=True)
    for key, value in defaults.items():
        await save_group_settings(grp_id, key, value)
    updated = await get_settings(grp_id)
    title = callback_query.message.chat.title
    text = generate_settings_text(updated, title, reset_done=True)
    buttons = [
        [InlineKeyboardButton("‚ôªÔ∏è  Ä·¥áÍú±·¥á·¥õ Íú±·¥á·¥õ·¥õ…™…¥…¢Íú±", callback_data=f"reset_group_{grp_id}")],
        [InlineKeyboardButton("üö´ ·¥Ñ ü·¥èÍú±·¥á", callback_data="close_data")]
    ]
    await callback_query.message.edit_text(text, reply_markup=InlineKeyboardMarkup(buttons), disable_web_page_preview=True)

@Client.on_message(filters.command("verify") & filters.user(ADMINS))
async def verify(bot, message):
    try:
        chat_type = message.chat.type
        if chat_type == enums.ChatType.PRIVATE:
            return await message.reply_text("·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö ·¥°·¥è Ä·¥ãs ·¥è…¥ ü è …™…¥ …¢ Ä·¥è·¥ú·¥òs!")
        if chat_type in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
            grpid = message.chat.id
            title = message.chat.title
            command_text = message.text.split(' ')[1] if len(message.text.split(' ')) > 1 else None
            if command_text == "off":
                await save_group_settings(grpid, 'is_verify', False)
                return await message.reply_text("‚úì ·¥†·¥á Ä…™Íú∞ è Íú±·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü ü è ·¥Ö…™s·¥Ä ô ü·¥á·¥Ö.")
            elif command_text == "on":
                await save_group_settings(grpid, 'is_verify', True)
                return await message.reply_text("‚úó ·¥†·¥á Ä…™Íú∞ è Íú±·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü ü è ·¥á…¥·¥Ä ô ü·¥á·¥Ö.")
            else:
                return await message.reply_text(" ú…™, ·¥õ·¥è ·¥á…¥·¥Ä ô ü·¥á ·¥†·¥á Ä…™Íú∞ è, ·¥ús·¥á <code>/verify on</code> ·¥Ä…¥·¥Ö ·¥õ·¥è ·¥Ö…™s·¥Ä ô ü·¥á ·¥†·¥á Ä…™Íú∞ è, ·¥ús·¥á <code>/verify off</code>.")
    except Exception as e:
        print(f"Error: {e}")
        await message.reply_text(f"Error: {e}")

@Client.on_message(filters.command('set_fsub'))
async def set_fsub(client, message):
    try:
        userid = message.from_user.id if message.from_user else None
        if not userid:
            return await message.reply("<b>You are Anonymous admin you can't use this command !</b>")
        if message.chat.type not in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
            return await message.reply_text("·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö ·¥Ñ·¥Ä…¥ ·¥è…¥ ü è  ô·¥á ·¥ús·¥á·¥Ö …™…¥ …¢ Ä·¥è·¥ú·¥òs")
        grp_id = message.chat.id
        title = message.chat.title
        if not await is_check_admin(client, grp_id, userid):
            return await message.reply_text(script.NT_ADMIN_ALRT_TXT)
        args = message.text.split(maxsplit=1)
        if len(args) < 2:
            return await message.reply_text(
                "·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥·¥Ñ·¥è·¥ç·¥ò ü·¥á·¥õ·¥á!\n\n"
                "·¥Ñ·¥Ä…¥ ·¥Ä·¥Ö·¥Ö ·¥ç·¥ú ü·¥õ…™·¥ò ü·¥á ·¥Ñ ú·¥Ä…¥…¥·¥á üs s·¥á·¥ò·¥Ä Ä·¥Ä·¥õ·¥á·¥Ö  ô è s·¥ò·¥Ä·¥Ñ·¥ás.  ü…™·¥ã·¥á: /s·¥á·¥õ_“ìs·¥ú ô …™·¥Ö1 …™·¥Ö2 …™·¥Ö3\n"
            )
        option = args[1].strip()
        try:
            fsub_ids = [int(x) for x in option.split()]
        except ValueError:
            return await message.reply_text('·¥ç·¥Ä·¥ã·¥á s·¥ú Ä·¥á ·¥Ä ü ü …™·¥Ös ·¥Ä Ä·¥á …™…¥·¥õ·¥á…¢·¥á Äs.')
        if len(fsub_ids) > 5:
            return await message.reply_text("·¥ç·¥Äx…™·¥ç·¥ú·¥ç 5 ·¥Ñ ú·¥Ä…¥…¥·¥á üs ·¥Ä ü ü·¥è·¥°·¥á·¥Ö.")
        channels = "·¥Ñ ú·¥Ä…¥…¥·¥á üs:\n"
        channel_titles = []
        for id in fsub_ids:
            try:
                chat = await client.get_chat(id)
            except Exception as e:
                return await message.reply_text(
                    f"{id} …™s …™…¥·¥†·¥Ä ü…™·¥Ö!\n·¥ç·¥Ä·¥ã·¥á s·¥ú Ä·¥á ·¥õ ú…™s  ô·¥è·¥õ …™s ·¥Ä·¥Ö·¥ç…™…¥ …™…¥ ·¥õ ú·¥Ä·¥õ ·¥Ñ ú·¥Ä…¥…¥·¥á ü.\n\nError - {e}"
                )
            if chat.type != enums.ChatType.CHANNEL:
                return await message.reply_text(f"{id} …™s …¥·¥è·¥õ ·¥Ä ·¥Ñ ú·¥Ä…¥…¥·¥á ü.")
            channel_titles.append(f"{chat.title} (`{id}`)")
            channels += f'{chat.title}\n'
        await save_group_settings(grp_id, 'fsub', fsub_ids)
        mention = message.from_user.mention if message.from_user else "Unknown"
        await client.send_message(
            LOG_API_CHANNEL,
            f"#Fsub_Channel_set\n\n"
            f"·¥úÍú±·¥á Ä - {mention} Íú±·¥á·¥õ ·¥õ ú·¥á Íú∞·¥è Ä·¥Ñ·¥á ·¥Ñ ú·¥Ä…¥…¥·¥á ü(Íú±) Íú∞·¥è Ä {title}:\n\n"
            f"Íú∞Íú±·¥ú ô ·¥Ñ ú·¥Ä…¥…¥·¥á ü(Íú±):\n" + '\n'.join(channel_titles)
        )
    except Exception as e:
        err_text = f"‚ö†Ô∏è Error in set_fSub :\n{e}"
        logger.error(err_text)
        await client.send_message(LOG_API_CHANNEL, err_text)



@Client.on_message(filters.private & filters.command("resetallgroup") & filters.user(ADMINS))
async def reset_all_settings(client, message):
    try:
        reset_count = await db.dreamx_reset_settings()
        await message.reply_text(
            f"<b>Íú±·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü ü è ·¥Ö·¥á ü·¥á·¥õ·¥á·¥Ö Íú±·¥á·¥õ·¥õ…™…¥…¢Íú± Íú∞·¥è Ä  <code>{reset_count}</code> …¢ Ä·¥è·¥ú·¥òÍú±. ·¥Ö·¥áÍú∞·¥Ä·¥ú ü·¥õ ·¥†·¥Ä ü·¥ú·¥áÍú± ·¥°…™ ü ü  ô·¥á ·¥úÍú±·¥á·¥Ö ‚úÖ</b>",
            quote=True
        )
    except Exception as e:
        print(f"[ERROR] reset_all_settings: {e}")
        await message.reply_text(
            "<b>üö´ An error occurred while resetting group settings.\nPlease try again later.</b>",
            quote=True
        )
        
@Client.on_message(filters.command('set_req_fsub')) #update
async def set_req_fsub(client, message):
    try:
        userid = message.from_user.id if message.from_user else None
        if not userid:
            return await message.reply("<b>You are Anonymous admin, you can't use this command!</b>")

        if message.chat.type not in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
            return await message.reply_text("·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö ·¥Ñ·¥Ä…¥ ·¥è…¥ ü è  ô·¥á ·¥ús·¥á·¥Ö …™…¥ …¢ Ä·¥è·¥ú·¥òs")

        grp_id = message.chat.id
        title = message.chat.title

        if not await is_check_admin(client, grp_id, userid):
            return await message.reply_text(script.NT_ADMIN_ALRT_TXT)

        args = message.text.split(maxsplit=1)
        if len(args) < 2:
            return await message.reply_text(
                "·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥·¥Ñ·¥è·¥ç·¥ò ü·¥á·¥õ·¥á!\n\n"
                "·¥Ñ·¥Ä…¥ ·¥Ä·¥Ö·¥Ö ·¥ç·¥ú ü·¥õ…™·¥ò ü·¥á  Ä·¥á«´·¥ú…™ Ä·¥á·¥Ö ·¥Ñ ú·¥Ä…¥…¥·¥á üs ·¥°…™·¥õ ú ·¥ä·¥è…™…¥  Ä·¥á«´·¥ú·¥ás·¥õ ·¥è…¥.\n"
                "·¥ús·¥Ä…¢·¥á: /s·¥á·¥õ_ Ä·¥á«´_“ìs·¥ú ô …™·¥Ö1 …™·¥Ö2 …™·¥Ö3"
            )

        option = args[1].strip()
        try:
            req_ids = [int(x) for x in option.split()]
        except ValueError:
            return await message.reply_text('·¥ç·¥Ä·¥ã·¥á s·¥ú Ä·¥á ·¥Ä ü ü …™·¥Ös ·¥Ä Ä·¥á …™…¥·¥õ·¥á…¢·¥á Äs.')

        if len(req_ids) > 5:
            return await message.reply_text("·¥ç·¥Äx…™·¥ç·¥ú·¥ç 5 ·¥Ñ ú·¥Ä…¥…¥·¥á üs ·¥Ä ü ü·¥è·¥°·¥á·¥Ö.")

        channels = " Ä·¥á«´·¥ú…™ Ä·¥á·¥Ö ·¥Ñ ú·¥Ä…¥…¥·¥á üs:\n"
        channel_titles = []

        for id in req_ids:
            try:
                chat = await client.get_chat(id)
            except Exception as e:
                return await message.reply_text(
                    f"{id} …™s …™…¥·¥†·¥Ä ü…™·¥Ö!\n·¥ç·¥Ä·¥ã·¥á s·¥ú Ä·¥á ·¥õ ú…™s  ô·¥è·¥õ …™s ·¥Ä·¥Ö·¥ç…™…¥ …™…¥ ·¥õ ú·¥Ä·¥õ ·¥Ñ ú·¥Ä…¥…¥·¥á ü.\n\nError - {e}"
                )

            if chat.type != enums.ChatType.CHANNEL:
                return await message.reply_text(f"{id} …™s …¥·¥è·¥õ ·¥Ä ·¥Ñ ú·¥Ä…¥…¥·¥á ü.")
            channel_titles.append(f"{chat.title} (`{id}`)")
            channels += f'{chat.title}\n'

        # Save to DB
        await save_group_settings(grp_id, 'reqfsub', req_ids)

        mention = message.from_user.mention if message.from_user else "Unknown"
        await message.reply_text(f"s·¥ú·¥Ñ·¥Ñ·¥áss“ì·¥ú ü ü è s·¥á·¥õ  Ä·¥á«´·¥ú…™ Ä·¥á·¥Ö ·¥Ñ ú·¥Ä…¥…¥·¥á ü(Íú±) “ì·¥è Ä {title} ·¥õ·¥è\n\n{channels}")
        await client.send_message(
            LOG_API_CHANNEL,
            f"#ReqFsub_Channel_Set\n\n"
            f"·¥úÍú±·¥á Ä - {mention} Íú±·¥á·¥õ ·¥õ ú·¥á  Ä·¥á«´·¥ú…™ Ä·¥á·¥Ö ·¥Ñ ú·¥Ä…¥…¥·¥á ü(Íú±) Íú∞·¥è Ä {title}:\n\n"
            f" Ä·¥á«´·¥ú…™ Ä·¥á·¥Ö ·¥Ñ ú·¥Ä…¥…¥·¥á ü(Íú±):\n" + '\n'.join(channel_titles)
        )


    except Exception as e:
        err_text = f"‚ö†Ô∏è Error in set_req_fsub:\n{e}"
        logger.error(err_text)
        await client.send_message(LOG_API_CHANNEL, err_text)


@Client.on_message(filters.command("reset_group"))
async def reset_group_command(client, message):
    grp_id = message.chat.id
    if message.chat.type not in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        return await message.reply_text("<b>‚ö†Ô∏è ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö ·¥Ñ·¥Ä…¥ ·¥è…¥ ü è  ô·¥á ·¥úÍú±·¥á·¥Ö …™…¥ …¢ Ä·¥è·¥ú·¥òÍú±</b>")
    is_admin = await is_check_admin(client, grp_id, message.from_user.id)
    if not is_admin:
        return await message.reply_text("<b>üö´  è·¥è·¥ú ·¥Ä Ä·¥á …¥·¥è·¥õ ·¥Ä…¥ ·¥Ä·¥Ö·¥ç…™…¥ …™…¥ ·¥õ ú…™Íú± …¢ Ä·¥è·¥ú·¥ò</b>")
    sts = await message.reply("<b>‚ôªÔ∏è ·¥ò Ä·¥è·¥Ñ·¥áÍú±Íú±…™…¥…¢  Ä·¥áÍú±·¥á·¥õ...</b>")
    await asyncio.sleep(1.2)
    await sts.delete()
    await save_default_settings(grp_id)
    btn = [[InlineKeyboardButton("üö´ ·¥Ñ ü·¥èÍú±·¥á", callback_data="close_data")]]
    reply_markup = InlineKeyboardMarkup(btn)
    await message.reply_text(
        "<b>‚úÖ Íú±·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±“ì·¥ú ü ü è  Ä·¥áÍú±·¥á·¥õ …¢ Ä·¥è·¥ú·¥ò Íú±·¥á·¥õ·¥õ…™…¥…¢Íú±</b>",
        reply_markup=reply_markup
    )

@Client.on_message(filters.command("trial_reset"))
async def reset_trial(client, message):
    user_id = message.from_user.id
    if user_id not in ADMINS:
        await message.reply(" è·¥è·¥ú ·¥Ö·¥è…¥'·¥õ  ú·¥Ä·¥†·¥á ·¥Ä…¥ è ·¥ò·¥á Ä·¥ç…™Íú±Íú±…™·¥è…¥ ·¥õ·¥è ·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö.")
        return
    try:
        if len(message.command) > 1:
            target_user_id = int(message.command[1])
            updated_count = await db.reset_free_trial(target_user_id)
            message_text = f"Íú±·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü ü è  Ä·¥áÍú±·¥á·¥õ Íú∞ Ä·¥á·¥á ·¥õ Ä·¥Ä…™ ü Íú∞·¥è Ä ·¥úÍú±·¥á ÄÍú± {target_user_id}." if updated_count else f"·¥úÍú±·¥á Ä {target_user_id} …¥·¥è·¥õ Íú∞·¥è·¥ú…¥·¥Ö ·¥è Ä ·¥Ö·¥è…¥'·¥õ ·¥Ñ ü·¥Ä…™·¥ç Íú∞ Ä·¥á·¥á ·¥õ Ä·¥Ä…™ ü  è·¥á·¥õ."
        else:
            updated_count = await db.reset_free_trial()
            message_text = f"Íú±·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü ü è  Ä·¥áÍú±·¥á·¥õ Íú∞ Ä·¥á·¥á ·¥õ Ä·¥Ä…™ ü Íú∞·¥è Ä {updated_count} ·¥úÍú±·¥á ÄÍú±."
        await message.reply_text(message_text)
    except Exception as e:
        await message.reply_text(f"An error occurred: {e}")
